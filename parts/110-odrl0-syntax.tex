%======================================================================
\chapter{ACCPL Syntax}
\label{chap:odrl0syntax}
%======================================================================

\section{Introduction}

We follow the style of~\cite{pucella2006} by using abstract syntax to express policy statements in \ac{ACCPL}. Abstract syntax is a more compact representation than XML which is what all the XML-based policy languages such \ac{odrl} use. Furthermore abstract syntax simplifies specifying the semantics as we shall see later. As an example the agreement ``the asset TheReport may be printed a total of 5 times by either Alice or Bob and twice more by Alice only'' written in \ac{odrl}'s XML encoding is illustrated in listing~\ref{lst:agreementxml}~\cite{pucella2006}. 


\lstset{language=XML}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[caption={Agreement for Alice and Bob in XML},label={lst:agreementxml}]
<agreement>
 <asset> <context> <uid> The Report </uid> </context> </asset>
 <permission>
   <print>
    <constraint> <count> 5 </count> </constraint>
   </print>
   <print>
    <constraint> <name> Alice </name> </constraint>
    <constraint> <count> 2 </count> </constraint>
   </print>
 </permission>
 <party> <context> <name> Alice </name> </context> </party>
 <party> <context> <name> Bob </name> </context> </party>
</agreement>
\end{lstlisting}
%\end{minipage} 

The agreement in Listing~\ref{lst:agreementxml} is shown in~\ref{lst:agreementpucella2006} using the syntax from~\cite{pucella2006}.

\lstset{language=Pucella2006}
\begin{lstlisting}[frame=single, caption={Agreement for Alice and Bob as BNF (as used in~\cite{pucella2006})},label={lst:agreementpucella2006}]
agreement
 for Alice and Bob 
 about The Report 
 with and[True -> count[5] => print, True -> and[Alice, count[2]] => print].
\end{lstlisting}


In the following we will cover the abstract syntax of \ac{ACCPL} that we later implement in Coq using constructs such as inductive types and definitions. 

\section{Environmental Facts}\label{sec:odrl0}
In \ac{ACCPL}, agreements and facts (i.e. environments) will refer to a count of how many times each policy should be and has been used to justify an action. This is the only fact that \ac{ACCPL} will cover although we conjecture adding other facts and the machinery to support those facts should not change verification goals and results so far of \ac{ACCPL}.

In \ac{ACCPL} a \syn{<prerequisite>} is either True, a \syn{<constraint>}, the negation of a \syn{<constraint>} or a conjunction of \syn{<prerequisite>}s. \syn{True} is the prerequisite that always holds. Constraints are facts that are outside of control of users. For example, there is nothing \syn{Alice} can do to satisfy the constraint ``user must be Bob''. In listing~\ref{lst:agreementpucella2006} we have a policy set (what follows the keyword `with') that is a conjunction of two base (or primitive) policy sets. Both primitive policy sets in this listing specify a \syn{<prerequisite>} of True. The first policy set contains a primitive policy which in turn is composed of a \syn{<prerequisite>} (\syn{count[5]}) and an action (first \syn{print}). The second policy set in listing~\ref{lst:agreementpucella2006} contains a primitive policy which specifies the action \syn{print} (second \syn{print} in the listing). The primitive policy belonging to the second policy set specifies a \syn{<prerequisite>} that is a conjunction of two primitive \syn{<prerequisite>}s: \syn{Alice} and \syn{count[5]}. Note that in \ac{ACCPL} we only support primitive policy sets i.e. no combining of policy sets using conjunctions or other combining operators. 


We will describe \ac{ACCPL} in a \emph{BNF} grammar that looks more like Pucella and Weissman's subset grammar~\cite{pucella2006}. BNF style grammars are more abstract as they only give suggestions about the surface syntax of expressions without getting into lexical analysis and parsing related aspects such as precedence order of operators~\cite{piercesf2011}. The Coq version in contrast is the encodings of the BNF definitions which is tyically used for building compilers and interpreters. We will present both the BNF definition and its Coq encoding for each construct of \ac{ACCPL}. 


\section{Productions} \label{sec:productionast}

The top level \ac{ACCPL} production is the \syn{<agreement>}. An agreement expresses what actions a set of subjects may perform on an object and under what conditions. Syntactically an agreement is composed of a set of subjects/users called a principal or \syn{<prin>}, an \syn{<asset>} and a \syn{<policySet>} (see listing~\ref{lst:agreementast}).

% agreement
\lstset{language=AST}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={agreement},label={lst:agreementast}]
<agreement> ::= 
     'agreement' 'for' <prin> 'about' <asset> 'with' <policySet> 
\end{lstlisting}
\end{minipage} 

Principals (\syn{<prin>}) are composed of \syn{<subject>}s which are specified based on the application e.g. \syn{Alice}, \syn{Bob}, etc (see listing~\ref{lst:prinast}).

% prin
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={prin},label={lst:prinast}]
<prin> ::=  { <subject$_{1}$>, ..., <subject$_{m}$> }
\end{lstlisting}

Assets are also application specific and we will continue using specific ones for the \ac{drm} application (taken from~\cite{pucella2006}). \syn{TheReport}, \syn{ebook}, and \syn{latestJingle} are examples of specific assets we will be using throughout. Syntactically an \syn{<asset>} is represented as a natural number (\syn{N}) (see listing~\ref{lst:assetast}). 
% asset
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={asset},label={lst:assetast}]
<asset> ::= N
\end{lstlisting}

Subjects are treated similarly to assets. A \syn{<subject>} is represented as a natural number (\syn{N}). See listing~\ref{lst:subjectast}).

% subject
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={subject},label={lst:subjectast}]
<subject> ::= N
\end{lstlisting}

Agreements express who may perform an action on an asset. They include a set of subjects (i.e. a principal), an asset and a policy set. A policy set is a primitive policy set implying non-nested policy sets. Note that we could define various combining operators for policy sets such as conjunctions and disjunctions but we keep \ac{ACCPL}'s policy sets limited to the primitive kind. We do however, use a policy combining operator when it comes to dealing with policies later on. Each primitive policy set specifies a \syn{<prerequisite>} and a \syn{<policy>}. Intuitively if the prerequisite ``holds'' the policy is taken into consideration. Otherwise the policy will not be looked at (see listing~\ref{lst:policySetast}).


% policySet
\newcommand*{\Comment}[1]{\hfill\makebox[7.0cm][l]{#1}}%
\lstset{mathescape, language=AST, escapechar=\&}  
\begin{lstlisting}[frame=single, caption={policySet and primPolicySet},label={lst:policySetast}]
<policySet> ::=  
   <primPolicySet>	&\Comment{; primitive policy set }&
   
<primPolicySet> ::=  
   <primInclusivePolicySet>	&\Comment{; primitive inclusive policy set }&
   <primExclusivePolicySet>	&\Comment{; primitive exclusive policy set }&
\end{lstlisting}

Some primitive policy sets are specified as inclusive as opposed to others that are explicitly specified as exclusive. Primitive exclusive policy sets are exclusive to agreement's users in that only those users may perform the actions specified in the policy set. The implication is that all other users who are not specified in the agreement's principal are forbidden from performing the specified actions, no matter whether the prerequisite holds or not (see listing~\ref{lst:primInclusivePolicySetast}).

% primInclusivePolicySet
\lstset{mathescape, language=AST, escapechar=\&}  
\begin{lstlisting}[frame=single, caption={primInclusivePolicySet},label={lst:primInclusivePolicySetast}]
<primInclusivePolicySet> ::=  
   <prerequisite> $\rightarrow$ <policy>	&\Comment{; primitive inclusive policy set }&
\end{lstlisting}

Not surprisingly we also define primitive inclusive policy sets that don't enforce any exclusivity to the agreement's users (see listing~\ref{lst:primExclusivePolicySetast}).

% primExclusivePolicySet
\lstset{mathescape, language=AST, escapechar=\&}  
\begin{lstlisting}[frame=single, caption={primExclusivePolicySet},label={lst:primExclusivePolicySetast}]
<primExclusivePolicySet> ::=  
   <prerequisite> $\mapsto$ <policy>	&\Comment{; primitive exclusive policy set }&
\end{lstlisting}

A primitive policy specifies an action to be performed on an asset, depending on whether the policy's prerequisite holds or not. If the prerequisite holds the agreement's user is permitted to perform the action on the agreement's asset; otherwise permission is denied. Pucella and Weissman's subset of \ac{odrl}~\cite{pucella2006} specify a unique identifier for each policy to help the translation (from agreements to formulas). \ac{ACCPL} has maintained the identifier for future work and we include it here in our definition of the policy construct however as far as the proofs are concerned the policy identifier could be removed without a loss to the obtained results (see listing~\ref{lst:primPolicyast}).

% primitive policy

\lstset{mathescape, language=AST, escapechar=\&}  
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={primPolicy},label={lst:primPolicyast}]
<primPolicy> ::=  
   <prerequisite> $\Rightarrow_{<policyId>}$ <act> 	&\Comment{; primitive policy}&
\end{lstlisting}
\end{minipage}

A policy is made up of primitive policies. Primitive policies are grouped together using the conjunction combining operator (see listing~\ref{lst:policyast}).

% policy

\lstset{mathescape, language=AST, escapechar=\&}  
\begin{lstlisting}[frame=single, caption={policy},label={lst:policyast}]
<policy> ::=  
 'and'[ <primPolicy$_{1}$>, ..., 
                 <primPolicy$_{m}$> ]	&\Comment{; conjunction }&
\end{lstlisting}


An action (\syn{<act>}) is represented as a natural number. Similar to assets and subjects, actions are application specific. Some example actions taken from~\cite{pucella2006} are \syn{Display} and \syn{Print} (see listing~\ref{lst:actast}).

% act
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={act},label={lst:actast}]
<act> ::= N
\end{lstlisting}

A policy identifier (\syn{<policyId>}) is a unique identifier specified as (increasing) positive integers (see listing~\ref{lst:policyIdast}).

% id
\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={policyId},label={lst:policyIdast}]
<policyId> ::= N
\end{lstlisting}

In \ac{ACCPL} a \syn{<prerequisite>} is either True or it is a \syn{<constraint>}. The True prerequisite always holds. A constraint is an intrinsic part of a policy and cannot be influenced by agreement's user. Minimum height requirements for popular attractions and rides are examples of what we would consider a constraint. A constraint can also be negative, specified by the keyword `not' in front of \syn{<constraint>}. Finally the set of prerequisites are closed under conjunction operator specified by the keyword `and' in front of the list of prerequisites separated by commas (see listing~\ref{lst:preRequisiteast}).

% prq

\lstset{mathescape, language=AST, escapechar=\&}  
\begin{lstlisting}[frame=single, caption={prerequisite},label={lst:preRequisiteast}]
<prerequisite> ::=  
	'True' &\Comment{; always true}&
	<constraint>	 &\Comment{; constraint}&
	'not' [ <constraint> ] &\Comment{; suspending constraint}&
	'and'[ <prerequisite$_{1}$>, ..., <prerequisite$_{m}$> ] &\Comment{; conjunction }&
\end{lstlisting}

Constraints are either of the principal kind, the count kind, or the count by principle kind. Principal constraints require matching to the users listed following the keyword \syn{<prin>}. For example, the constraint of ``the user being Alice'' is a constraint of type principal. A count constraint refers to the number of times the user of an agreement has invoked policies to justify her actions. If the count constraint is part of a policy then the count refers to that single policy. In the case that the count constraint is part of a policy set or if the policy is a conjunction, then the count refers to the set of policies specified in the policy set or in the policy conjunction as the case may be (see listing~\ref{lst:constraintast}).

% constraint
\lstset{mathescape, language=AST, escapechar=\&}  
\begin{lstlisting}[frame=single, caption={constraint},label={lst:constraintast}]
<constraint> ::=  
	<prin> &\Comment{; principal}&
	'Count' [N] &\Comment{; number of executions}&
	<prin> ('Count' [N]) &\Comment{; number of executions by prin}&
\end{lstlisting}
