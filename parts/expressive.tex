%======================================================================
\chapter{Expressive Power of ACCPL}
%======================================================================

We have mentioned previously about the trade-offs we have made in the design of \ac{ACCPL} between ease of formal proof of correctness and expressive power. We started out by examining Pucella and Weissman's fragment of \ac{odrl}~\cite{pucella2006} focusing on what we believed to be the essence or core of their language in terms of expressive power at the same time staying away from some of the more complex constructs in order to achieve our goal of ease of reasoning about the policies written in \ac{ACCPL} with respect to specific questions such as the decidability problem we discussed in chapter~\ref{chap:intro}. In the following sections we will review differences between \ac{ACCPL} and Pucella and Weissman's fragment of \ac{odrl} including the syntactic constructs we have left out of \ac{ACCPL} and discuss whether and how much expressive power has been lost by making \ac{ACCPL} a small language.

\section{Requirements}

Policies in \ac{odrl} as specified by~\cite{pucella2006} are composed of a prerequisite, an action and a unique identifier. A prerequisite is either true, a constraint, a requirement or a condition. Constraints are facts that users don't control such as the constraint that ``user must be Bob'' (users other than Bob cannot satisfy this constraint). Requirements are facts that users have control over. For example, ``Alice has paid 5 dollars" can come true if Alice pays 5 dollars. \ac{odrl} also includes constraints that must not hold in the form of conditions. 

As mentioned in previous chapters, \ac{ACCPL} forgoes requirements completely and moves the condition ``the negation of a constraint'' as a syntactic element under the <constraint> production (see~\ref{lst:preRequisiteast} and~\ref{lst:constraintast} in chapter~\ref{chap:odrl0syntax}). In addition \ac{ACCPL} excludes the ``forEachMember'' constraint specified by~\cite{pucella2006}. Requirements in \ac{odrl} as specified by~\cite{pucella2006} have a significantly different and more complex translation than other prerequisites because of their dependence on time. For example, the ``inSeq[req1, req2]'' requirement holds only if ``req1'' is met before ``req2'' requirement. The translation for ``forEachMember'' is a formula that holds if each sub-constraint in ``forEachMember'' is met by each member mentioned in the constraint. We acknowledge that by removing requirements and the forEachMember constraint, expressive power may have been significantly reduced, however it is not clear how much expressive power is lost when \ac{ACCPL} is considered as a general access-control language as opposed to a \ac{drm} specific policy language. We also anticipate that adding these missing constructs or similar ones to \ac{ACCPL} or trying to implement them in terms of existing \ac{ACCPL} constructs would add significant complexity to the semantics and derivation of proofs.

\section{PolicySet Combinators}  

Policy sets in \ac{odrl} as specified by~\cite{pucella2006} may be combined using the conjunction operator. This possibility certainly adds to the expressive power of a language, similar to the case of basic policies when they are combined. In \ac{ACCPL} we have only retained basic policy sets that don't contain other policy sets. While this means \ac{ACCPL} is less expressive this design decision was made to make the language respect the ``independent composition'' property (see section~\ref{sec:indepcompos}) and as a consequence be conflict-free (the answer to a access query will be either granting or denying but not both). 

Adding the conjunction operator to policy sets in \ac{ACCPL} should be straight forward in terms of the infrastructure we would needs to add. However, this addition would open the door to possibility of conflicts and additionally the current established results for \ac{ACCPL} would no longer hold. For conflict detection and reporting, we would add an extra identifier to each policy that signifies which policy set a basic policy belongs to. We would also enhance the \syn{result} data-structure to include both the policy set and policy identifiers in order to help the policy writers fix their policies in case the conflict was not intended. Since allowing policy set conjunction opens the door to conflicting decisions, we can envisage adding policy set combination algorithms such as permit-overrides or deny-overrides to resolve any conflicts if and when they occur. 

\subsection{Possible Conflict Detection Discussion if policy set conjunction is added}  
