%======================================================================
\chapter{Further Future Work Directions}
%======================================================================

%----------------------------------------------------------------------
%\section{Summary}
%
%We started off by looking at \ac{drel}s and specifically at \ac{odrl} and considered its formal semantics as captured by~\cite{pucella2006}. We presented the encodings and semantics of the constructs for a significant subset of \ac{odrl} in Coq and then defined what queries looked like and what the decision problem was in this context. We have also encoded the decision algorithms as presented in~\cite{pucella2006} in Coq in order to perform formal verification of theorems of interest. We noted the common thread between \ac{rel}s and policy languages for access control systems such as those between \ac{odrl} and \ac{selinux}. We discussed the goal of generalizing the concept of a policy language from strictly representing subsets of \ac{odrl}, to representing (subsets of) both \ac{odrl} and \ac{selinux} policy languages with the goal of applying the decision algorithms to both types of policies, in a unified manner.
%%----------------------------------------------------------------------
%
%
%\section{Machine-Checked Proof of Decidability of Queries}
%
%By defining formal semantics for \ac{odrl} authors of~\cite{pucella2006} were able to show some important results. First result is that answering the question of whether a set of ODRL statements imply a permission, denial or other possibilities is decidable and also that its complexity is NP-hard.
%
%The authors of~\cite{pucella2006} then prove that by removing the construct $not[policySet]$ from \ac{odrl}'s syntax answering the same query remains decidable and efficient (polynomial time complexity). 
%
%We will prove equivalent results as above starting with the decidability result of answering a query in ODRL0 (which does not include $not[policySet]$). The theorem in listing~\ref{lst:decidabilityodrl0coq} states that for all environments, all single agreements, all subjects, all actions and all assets, either permission is granted, permission is denied, permission is unregulated or query is inconsistent. 
%
%\lstset{language=Coq, frame=single, caption={Environments and Counts},label={lst:decidabilityodrl0coq}}
%\begin{minipage}[c]{0.95\textwidth}
%\begin{lstlisting}
%Theorem queriesAreDecidable: forall (e:environment), 
%                forall (agr: agreement),
%                forall (s:subject),
%                forall (action:act),
%                forall (a:asset),
%
%(permissionGranted e [agr] s action a) \/
%(permissionDenied e [agr] s action a)  \/
%(queryInconsistent e [agr] s action a) \/
%(permissionUnregulated e [agr] s action a).
%
%\end{lstlisting}
%\end{minipage}
%
%We will then augment ODRL0 with the constructs we omitted from the full ODRL (resulting in what we have earlier called ODRL1 or ODRL2) including the troublesome construct $not[policySet]$ and attempt to prove that the decidability results remain intact. There is a chance that a proof is not possible due to particulars of the Coq encoding we have used, in in which case, we will adjust our encoding.

 
We have designed \ac{ACCPL} as a suitable core policy language for \ac{pbac} systems that can be used for expressing general access-control expressions and also as a target language for deploying
policies written in other languages. We could capture, implement and study the semantics of these other policy-based access-control using the \ac{ACCPL} translation function framework and ultimately certify the semantics of those languages with respect to their specifications the same way \ac{ACCPL} has been certified.

\section{SELinux}

While \ac{xacml} is a high-level and platform independent access control system, \ac{selinux} is platform dependent (e.g. Linux based) and low-level. \ac{selinux} enhances the \ac{DAC} that most unix based systems employ by \ac{MAC} where designed access control policies are applied throughout the system possibly overriding whatever \ac{DAC} is in place by the system users. 

\ac{selinux} uses Linux's extended file attributes to attach a \emph{security context} to passive entities (e.g. files, directories, sockets) and also to each active entity, typically a Linux user space process. Security context is a data structure that is composed of a user, a role and a domain (or type). While users can map directly to ordinary user names they can also be defined separately. Roles are meant to group users and add flexibility when assigning permissions and are the basis for \ac{rbac} in \ac{selinux}. Finally domains or types are the basis for defining common access control requirements for both passive and active entities. 


The enforcement of \ac{selinux} policies are performed by the \emph{security server}. Whenever a security operation is requested from the Linux kernel by a program running in user space, the security server is invoked to arbitrate the operation and either allow the operation or to deny it. Each operation is identified by two pieces of information: an object class (e.g. file) and a permission (e.g. read, write). When an operation is requested to be performed on an object, the class and the permissions associated with the object along with security contexts of the source (typically the source entity is a process) and the object are passed to the security server. The security server consults the loaded policy (loaded at boot time) and allows or denies the access request~\cite{Sarna}.

\section{SELinux Policy Language}

The \ac{selinux} policy has four different kinds of statements: declarations, rules, constraints and assertions~\cite{ArcherLP03}. Assertions are compile time checks that the \syn{checkpolicy} tool performs at compile time. The other three kinds of statements however are evaluated at run-time. 

Declaration statements are used to declare types, roles and users. Type declaration statements are used to introduce new types. Roles are declared and authorized for particular domains (types) through role declarations, and finally user declarations are used to define each user and to specify the set of authorized roles for each of these users (see~\ref{lst:declsselinux}). In the following listings we will present a simplified and modified version of the official \ac{selinux} syntax that accomadates better the use of the \ac{ACCPL} Coq framework.

\lstset{language=selinux}
\begin{lstlisting}[frame=single, caption={Declaration Statements},label={lst:declsselinux}]

'type' T ';' &\Comment{; type T}&

'role' R T ';' &\Comment{; role R is associated with type T }&

'user' U R ';' &\Comment{; user U is associated with role R }&

\end{lstlisting}

Rule statements define access vector rules. Access vector (AV) rules (see listing~\ref{lst:avruleselinux}) specify which operations are allowed and whether to audit (log). Any operation not covered by AV rules are denied by default and all denied operations are logged. The semantics of the AV rule with \syn{<avkind>} \syn{allow} is: processes with type \syn{T1} are allowed to perform operations in \syn{P} on objects with class \syn{C} and type \syn{T2}. Note that in our modified syntax for \ac{selinux} we will use an explicit \syn{deny} as can be seen in listing~\ref{lst:avruleselinux}.

\lstset{language=selinux}
\begin{lstlisting}[frame=single, caption={AV Rule},label={lst:avruleselinux}]

<avRule> ::= <avkind> T1 T2:C P ';'

<avkind> ::= 'allow' | 'deny'
\end{lstlisting}

When a process changes security context, the role may change, assuming a ``role transition'' rule exists, relating the old and the new roles. There is a related AV rule called the ``type transition'' rule where a process with type \syn{T1} is allowed/denied to transition to type \syn{T2} when C=process and P=transition (see~\ref{lst:typeAndroletransselinux}).

\lstset{mathescape, language=AST} 
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={Type Transition and Role-Allow Rules},label={lst:typeAndroletransselinux}]
<avkind> T1 T2:process transition ';'

<role_transition_rule> ::= <avkind> R1 R2 ';' &\Comment{; when a process changes security contexts this rule must hold }&
\end{lstlisting}
\end{minipage}

Constraints are additional conditions on permissions in the form of boolean expressions that must hold in order for the specified permissions to be allowed (see listing~\ref{lst:constrainselinux}). Whenever a permission is requested on an object class C, the security server checks that the constraints hold.

\lstset{language=selinux}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={Constraint Definition},label={lst:constrainselinux}]

<constraint> ::= 'constrain' C, P, <expr> ';'

<expr> ::= 'not' <expr> | <expr> 'and' <expr> | <expr> or <expr> | U1 <op> U2 | T1 <op> T2 | R1 <op> R2

<op> ::= '==' | '!='
\end{lstlisting}
%\end{minipage}

\section{Agreements in SELinux}

We will start by limiting the \ac{selinux} policy language to only allow AV rules. As mentioned earlier an operation not covered by an allow rule is denied by default in \ac{selinux} proper. We will make up explicit deny rules, such that an agreement is defined to be a combination of allow and deny rules. Allow and deny rules as mappings are defined in listing~\ref{lst:allowmappingastselinux}.

\lstset{language=AST}
\begin{lstlisting}[frame=single, caption={'allow'/'deny' Rule as a Mapping},label={lst:allowmappingastselinux}]
AV rule : $T \times (T \times C) \rightarrow 2^{P}$
\end{lstlisting}

\lstset{language=AST}
\begin{lstlisting}[frame=single, caption={\ac{selinux} Agreement},label={lst:agreementastselinux}]
<agreement> ::= <avRule> ';' <agreement> 
\end{lstlisting}


\section{Environments}

Environments are collections of \emph{role-type} and \emph{user-role} relations. A role-type relation \syn{role(R, T)} simply associates a role with a type. A user-role relation \syn{user(U, R)} associates a user with a role. An environment is consistent with respect to a security context \syn{<T, R, U>}, if and only if \syn{role(R, T)} and \syn{user(U, R)} relations hold in the environment. 

\section{Queries in SELinux}

The decision problem in \ac{selinux} access control is whether an entity with security context \syn{<T1, R1, U1>} may perform action \syn{P1} to entity with object class \syn{C1} with security context \syn{<T2, R2, U2>}.

To answer such queries we use the authorization relation \syn{auth(C, P, T1, R1, U1, T2, R2, U2)} which is conceptually equivalent to the \syn{Permitted} answer from \ac{ACCPL} (see listing~\ref{lst:fqplussel}).

\lstset{mathescape, language=AST} 
\begin{lstlisting}[frame=single, caption={\syn{Permitted} for \ac{selinux}},label={lst:fqplussel}]
$allow (T1, T2, C, P)$ $\land$ $(E$ $consistent$ $wrt$ <T1, R1, U1> $\land$ <T2, R2, U2>) $\land$ $(((C,P)==(process, transition))$ $\implies$ $allow (R1, R2))$ $\implies auth(C, P, T1, R1, U1, T2, R2, U2)$ 
\end{lstlisting}

The negation of the authorization relation \syn{auth(C, P, T1, R1, U1, T2, R2, U2)} is conceptually equivalent to the \syn{NotPermitted} answer from \ac{ACCPL} (see listing~\ref{lst:fqminussel}).

\lstset{mathescape, language=AST} 
\begin{lstlisting}[frame=single, caption={\syn{NotPermitted} for \ac{selinux}},label={lst:fqminussel}]

$deny (T1, T2, C, P)$ $\lor$ $\lnot (E$ $consistent$ $wrt$ <T1, R1, U1> $\land$ <T2, R2, U2>) $\lor$ $(((C,P)==(process, transition))$ $\implies$ $deny (R1, R2))$ $\implies \lnot auth(C, P, T1, R1, U1, T2, R2, U2)$ 

\end{lstlisting}

\section{Decidability of Queries in SELinux}

As future work, we will be investigating the question of decidability for answering queries given an \ac{selinux} policy. We will first state a decidability theorem similar to the theorem in listing~\ref{lst:agreementdecidablecoq} (minor adjustments may be needed to allow for differences with \ac{selinux} policy language) and present a proof for it in Coq. Most policy based access-control languages typically use a two-valued decision set to indicate whether an access request is granted or denied. The literature for the \ac{selinux} implies only these two outcomes are possible so initially we will attempt to prove this conjecture in Coq. 

As a next step for future work on \ac{selinux}, we will add constraint relations to our simplified \ac{selinux} policy language and prove the decidability results stand for the augmented policy language.

\section{Related Work}

Policies in some \ac{pbac} languages such as \ac{xacml} and \ac{odrl} are expressed in \ac{xml}. Authors of~\cite{surveyXML} do a survey of XML-based access control languages describing and comparing the following languages and systems: Author-X, FASTER, \ac{odrl}, \ac{xrml}, \ac{xacl}, \ac{saml}, \ac{xacml} and the language designed by the authors called \ac{spl}. Other examples are WS-Policy, \ac{wsdl} and \ac{wspl} reviewed in~\cite{ArdagnaDVS04}.

Authors of~\cite{ArdagnaDVS04} argue that \ac{xml}-based \ac{pbac} systems are well suitable for the Internet context where simplicity and easy integration with existing technology and tools must be ensured. \ac{xml}-based languages are also well suited for the easy interchange of policies~\cite{ArdagnaDVS04}. 

While policies in \ac{xml}-based languages are expressed using \ac{xml}, the meaning of the policy statements in such languages are expressed using fragments of a natural language like English, resulting in ambiguity with regards to the intended behaviour of the system encoded in these policy statements. The ambiguity in semantics of these languages may lead to implementations varying in their interpretations of the access-control language and ultimately making real the possibility of security breaches (e.g. access granted to unauthorized subjects). 

In the following sections we will review related work and approaches to define semantics for \ac{pbac} based languages such that one can determine without any ambiguity whether a permission or prohibition follows from a set of policy statements.
 
\section{Lithium}
Halpern and Weissman~\cite{Halpern2008} use \ac{fol} to represent and reason about policies; policies describes the conditions under which a request to perform an action, such as reading a file, is granted or denied. They restrict \ac{fol} to get tractability for answering the query of whether a request to access a resource may be granted or denied, given a policy, and argue that despite the tractability results their language is still expressive. They contrast their approach with approaches based on Datalog~\cite{datalog} and point out that Datalog based work is made tractable by restricting function symbols and negation but at the cost of losing some expressive power. For example, Datalog based languages cannot distinguish between rendering explicitly forbidden decisions vs unregulated ones.

Halpern and Weissman~\cite{Halpern2008} focus on satisfying three requirements in the design of Lithium:
\begin{quote}
\begin{enumerate}
  \item It must be expressive enough to capture in an easy and natural way the policies that people want to discuss.
  \item It must be tractable enough to allow interesting queries about policies to be answered efficiently.
  \item It must be usable by non-experts, because we cannot expect policymakers and administrators to be well-versed in logic or programming languages.
\end{enumerate}
\end{quote}
We note although \ac{ACCPL} may be a good candidate to satisfy Halpern and Weissman's first goal, this was not a primary goal for \ac{ACCPL}. \ac{ACCPL} was designed as a core policy language with certified semantics such that it could be extended in various ways to add expressiveness as long as the semantics would remain certified with respect to various results established for \ac{ACCPL} (e.g. decidability results).  

As far as the Halpern and Weissman's second goal, we note that for \ac{ACCPL} tractability of answering an access query was not a goal; instead \ac{ACCPL} focused on achieving decidability results with respect to answering the access query. The third requirement Lithium was designed to satisfy, namely the usability of the language for non-experts was simply not a goal for \ac{ACCPL}. 

\section{Trace-based Semantics}
Gunter, et al~\cite{GunterWW01} propose an abstract model and a formal language to express access and usage rights for digital assets. A set of ``realities'' representing a sequence of \emph{payment} and \emph{render} (e.g. work is rendered by a device) actions make up a license. Semantics in the authors' model are expressed as a function mapping terms of the language to elements of the domain of licenses. The authors argue that their semantics is similar to those used for concurrency where language constructs are modelled as traces of allowed events.

Xiang, et al~\cite{xiang2008formal} use \ac{ots} modeling to describe licenses to use digital assets. In this formalism licenses and \ac{drm} systems are modeled as \ac{ots}s, described in CafeOBJ~\cite{cafeobj} which is an algebraic specification language. The authors' approach not only models static properties of licenses, dynamic evolutions or traces of licenses can also be observed and denoted by the actions in \ac{ots}s, respectively. Finally, formal verification of licenses expressed in CafeOBJ may be performed using a theorem proving facility which provides an integrated platform for the formal modeling, specification, and verification of licenses and \ac{drm} systems. This feature enables one to analyze and prove the licenses as well as \ac{drm} systems in a more effective way.

\section{Semantics Based on Linear Logic}

Barth and Mitchell~\cite{BarthM06} express semantics of digital rights using propositional linear logic. Linear logic deals with dynamic properties or finite resources, while classical logic deals with stable truths, or static properties~\cite{Girard87}. According to Girard as cited by Lincoln~\cite{Lincoln}, ``Linear logic is a resource conscious logic''. Bart and Mitchell introduce the notion of monotonicity which captures the idea that acquiring extra rights by a user should not lead to the user having fewer rights and show that the algorithm the \ac{oma} uses for assigning actions to rights is non-monotonic. Barth and Mitchell consider whether a sequence of actions complies with a license and show that answering this question for the \ac{oma} language is NP-complete. They propose an algorithm based on propositional linear logic to evaluate sequences of actions that is monotonic.

\section{Automata-based Semantics}
Holzer, et al~\cite{Holzer} give a semantics for \ac{odrl} that models the actions that are allowed according to a contract or an agreement. This model is presented in terms of automata. Each trace through the automaton represents a valid sequence of actions for each participant. The states of the automaton encode the state of the license at each point in time, meaning, which actions are allowed at what point considering the action that have taken place in the past. \ac{odrl} requirements and constraints are modeled as labels that are associated with edges in the automaton: an edge can only be taken if the related requirement is satisfied. 

Sheppard and Safavi-Naini~\cite{SheppardS09} point out that Holzer et al, don't present an algorithm in~\cite{Holzer} for building their automaton, leading to the conclusion that the examples in their paper are constructed by hand.

\section{Operational Semantics Based}
Sheppard and Safavi-Naini~\cite{SheppardS09} propose an operational model for both formalizing and enforcing digital rights using a \emph{right expression compiler}. They use their model to develop operational semantics for \ac{oma}, from which an interpreter could be derived. The authors argue their semantics provide for 
\begin{quote}
\begin{itemize}
  \item Actions whose effects are neither instantaneous nor fallible.
  \item Constraints whose satisfaction changes over time.
  \item Constraints that modify the form of an action rather than permit or prohibit it outright. The quality and watermark constraintsof \ac{odrl}, for example, modify an action by altering the resolution of the output and inserting a watermark, respectively.
\end{itemize}
\end{quote}


To show that an \ac{pbac} systems actually behaves correctly with respect to its specification, proofs are needed, however the proofs that are often presented in the literature (e.g.~\cite{Halpern2008, pucella2006, Tschantz}), are hard or impossible to formally verify. The verification difficulty is partly due to the fact that the language used to do the proofs while mathematical in nature, utilizes intuitive justifications to derive the proofs. Intuitive language in proofs means that the proofs could be incomplete and/or contain subtle errors. 

\section{Conflict Detection Algorithms}

In the following we will review some related work to ours where the authors have used the Coq Proof Assistant to develop conflict detection algorithms (for policies in particular \ac{pbac} languages), to state theorems and specifications about the behaviour of their algorithms, to develop formal proofs of those theorems and finally to machine-check those proofs. The resulting proofs are certified, meaning they provide strong correctness guarantees, due to the fact that they are machine-checked.

Capretta et al~\cite{CaprettaSFM07} present an conflict detection algorithm for the Cisco firewall specification~\cite{ciscofirewall} and formalize a correctness proof for it in the Coq proof assistant. They define two rules being in conflict as, given a access request, one rule would allow access while the another rule would deny access. The authors present their algorithm in Coq's functional programming language along with access rules and requests which are also encoded in Coq. An OCaml version of
the algorithm is extracted and successfully used on actual firewall specifications. The extracted program, according to the authors, can detect conflicts in firewalls with hundreds of thousands of rules. Capretta et al also prove in~\cite{CaprettaSFM07} that their algorithm finds all conflicts and only the correct conflicts in a set of rules. The algorithm is therefore verified formally to be both sound and complete.

St-Martin and Felty~\cite{Stmartin} represent policies for a fragment of \ac{xacml} 2.0 in the Coq proof assistant and propose an algorithm for detecting conflicts in \ac{xacml} policies. They state and prove correctness of their algorithm in the Coq proof assistant. Their \ac{xacml} subset includes some complex conditions such as time constraints. The authors compare their work with the conflict detection presented in~\cite{CaprettaSFM07} and conclude that conflict detection in \ac{xacml} is more complex and results in having to consider many cases including many subtle corner cases. 

St-Martin and Felty's definition of a conflict is the usual one and is similar to the one defined in~\cite{CaprettaSFM07} for firewall rules: when one rule in a policy permits a request and another denies the same request. Since \ac{xacml} allows conflicts by design, rule-combining is also provided. A rule-combining algorithm is meant to resolve conflicts if more than one rule applies. For example, one strategy (or algorithm) for resolving conflicts would be to use the first applicable rule that applies. Policy writers often make use of rule-combining algorithms, but unintended errors such as of conflicts are common.St-Martin and Felty's conflict detection algorithm provides a tool for static analysis and policy debugging and it finds all conflicts, whether intended or not. Policy maintainers may then use the results of running the algorithm on their policies to decide which errors or conflicts were intended and which were not.


NOW CLOSE WITH YOUR WORK


GO OVER MY CONCLUSIONS/CONTRIBUTIONS AGAIN





























