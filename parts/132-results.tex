%======================================================================
\chapter{Formal Proofs and Decidability}\label{chap:results}
%======================================================================

                  
%----------------------------------------------------------------------
The tension in designing a policy language is usually between how to make the language expressive enough, such that the design goals for the policy language may be expressed, and how to make the policies verifiable with respect to the stated goals. A central question or goal in policy language design is whether a permission is implied by a set of policy statements. This is referred to as the decidability problem in this thesis. For example, Halpern and Weissman show that in general determining whether a permission is implied by a set of policy statements in \ac{xrml} is undecidable~\cite{HalpernW08} whereas Pucella and Weissman show that answering such questions is decidable but NP-hard for \ac{odrl}~\cite{pucella2006}.
 

We had set out to prove formally that the \ac{ACCPL} language was decidable. Recall that we specified the semantics of \ac{ACCPL} using a translation from policy statements to decisions. The goal was to use the translation algorithm to determine when a request for accessing a resource is implied by a given policy, when the request is not implied by the policy and finally when the request is not regulated by the given policy. More importantly we wanted to show that answering access requests always produced a decision and that the translation algorithm terminated on all input policies with a decision of granted, denied or unregulated. In this chapter we discuss the decidability proofs and other main results we had set out to accomplish. We will also show that the translation algorithm meets its specification and computes the correct decision, with respect to its specification, given a policy. 


\ac{ACCPL} started out as a reduced version of Pucella and Weissman's subset of \ac{odrl}\\~\cite{pucella2006} but based on the direction of the proofs we were developing significant changes had to be made to Pucella and Weissman's subset to make the proofs possible. An important lesson learned was that the process of designing a certifiable policy language cannot be done in isolation since while certifiability of the language derives the design one way, expressiveness requirements of the language usually drive it in the opposite direction. Certifiability cannot be a post-design activity as the changes it will impose are often fundamental ones.

In the following section we will list the main theorems that we have proved and the supporting theorems that needed to be proved to lead up to the main results. In general however we will not show the actual proofs in the dissertation (with some exceptions) and instead refer the reader to the GitHub repository where the source code for \ac{ACCPL}, including the proofs, lives~\cite{BahmanSistany2015}.

\section{Decidability of ACCPL}\label{sec:maintheorems}

The theorem \syn{trans_agreement_dec2} is the declaration of the main decidability result for \ac{ACCPL} (see listing~\ref{lst:agreementdecidablecoq}). Together with other theorems we will describe below, we have ``certified'' \ac{ACCPL} decidable by proving this theorem. The nonempty list that the agreement translation function \syn{trans_agreement} returns will contain results one per each primitive policy (\syn{primPolicy}) found in the agreement. Specifically the predicate \syn{isResultInQueryResult} takes a result and a nonempty list of results which \syn{trans_agreement} produces, and calls the \syn{In} predicate. The \syn{In} predicate is adapted from the \syn{Coq.Lists.List} standard library and checks for the existence of the input \syn{result} in the nonempty list of results. Definitions for predicates \syn{isResultInQueryResult} and \syn{In} are listed in listing~\ref{lst:agreementdecidablecoq}. The definitions for \syn{answer} and \syn{result} are repeated in the same listing. 

As an example and also a visual aid to understanding how queries are answered, see listing~\ref{lst:permittedcoq}. The \syn{isResultInQueryResult} predicate looks for a result with an answer of Permitted in the list that \syn{trans_agreement} has produced, for an agreement for three primitive policies (since the set contains three results). Intuitively, we are asking whether Alice is \syn{Permitted} to Print the ebook given a policy.  

\lstset{language=Coq, frame=single, caption={Access Request Is \syn{Permitted}},label={lst:permittedcoq}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
isResultInQueryResult
(Result Permitted Alice Print ebook) 
[ (Result Unregulated Alice Print ebook) ; (Result Unregulated Alice Print ebook) ; (Result Permitted Alice Print ebook) ]
\end{lstlisting}
%\end{minipage}
    
In the case where the whole set is not comprised of \syn{Unregulated} results, we have two mutually exclusive cases. The first case is when the set has a at least one \syn{Permitted} result; we answer the access query in this case with a result of \syn{Permitted} (this would be the case in the listing~\ref{lst:permittedcoq}). The second case is when the set has at least one \syn{NotPermitted}; we answer the access query in this case with a result of \syn{NotPermitted} (see answer and result types in~\ref{sec:answerandresulttypes}).


\lstset{language=Coq, frame=single, caption={Agreement Translation is Decidable},label={lst:agreementdecidablecoq}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Definition isResultInQueryResult (res:result)(results: nonemptylist result) : Prop :=
  In res results.

Fixpoint In (a:X) (l:nonemptylist) : Prop :=
    match l with
      | Single s => s=a
      | NewList s rest => s = a \/ In a rest
    end.

Inductive answer : Set :=
  | Permitted : answer
  | Unregulated : answer
  | NotPermitted : answer.

Inductive result : Set :=
  | Result : answer -> subject -> act -> asset -> result.

Theorem trans_agreement_dec2:
  forall
  (e:environment)(ag:agreement)(action_from_query:act)
   (subject_from_query:subject)(asset_from_query:asset),


 (isResultInQueryResult 
    (Result Permitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query)) 
\/

 (isResultInQueryResult 
    (Result NotPermitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query))
\/

 (~(isResultInQueryResult 
    (Result Permitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query)) /\
  ~(isResultInQueryResult 
    (Result NotPermitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query))).

\end{lstlisting}
%\end{minipage}

Typically most, if not all of the results will be of type \syn{Unregulated}. In the case where all the results are \syn{Unregulated} we answer the access query with a result of \syn{Unregulated}. We show this case indirectly in the theorem in listing~\ref{lst:agreementdecidablecoq} by stating the set does not contain a \syn{Permitted} result nor a \syn{NotPermitted} result. 

\section{Mutual Exclusivity of \syn{Permitted} and \syn{NotPermitted}}

The \syn{trans_agreement_perm_implies_not_notPerm_dec} (see listing~\ref{lst:permimpliesnotnotperm}) says that the existence of a \syn{Permitted} result in the set of results returned by \syn{trans_agreement}, excludes a \syn{NotPermitted} result.


\lstset{language=Coq, frame=single, caption={\syn{Permitted} result Implies no \syn{NotPermitted} result},label={lst:permimpliesnotnotperm}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem trans_agreement_perm_implies_not_notPerm_dec:
  forall
    (e:environment)(ag:agreement)(action_from_query:act)
    (subject_from_query:subject)(asset_from_query:asset),

    (isResultInQueryResult 
      (Result Permitted subject_from_query action_from_query asset_from_query)
        (trans_agreement e ag action_from_query subject_from_query asset_from_query)) ->

   ~(isResultInQueryResult 
      (Result NotPermitted subject_from_query action_from_query asset_from_query)
       (trans_agreement e ag action_from_query subject_from_query asset_from_query)).
\end{lstlisting}
%\end{minipage}


The  \syn{trans_agreement_NotPerm_implies_not_Perm_dec} (see listing~\ref{lst:notpermimpliesnotperm}) shows that the existence of a \syn{NotPermitted} result in the set of results returned by \syn{trans_agreement}, excludes a \syn{Permitted} result.

\lstset{language=Coq, frame=single, caption={\syn{NotPermitted} result Implies no \syn{Permitted} result},label={lst:notpermimpliesnotperm}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem trans_agreement_NotPerm_implies_not_Perm_dec:
  forall
    (e:environment)(ag:agreement)(action_from_query:act)
    (subject_from_query:subject)(asset_from_query:asset),

    (isResultInQueryResult 
      (Result NotPermitted subject_from_query action_from_query asset_from_query)
        (trans_agreement e ag action_from_query subject_from_query asset_from_query)) ->

   ~(isResultInQueryResult 
      (Result Permitted subject_from_query action_from_query asset_from_query)
       (trans_agreement e ag action_from_query subject_from_query asset_from_query)).
\end{lstlisting}
%\end{minipage}

Finally the proof for \syn{trans_agreement_not_Perm_and_ \newline NotPerm_at_once} establishes that both \syn{Permitted} and \syn{NotPermitted} results cannot exist in the same set returned by \syn{trans_agreement} (see listing~\ref{lst:permandnotpermmutualexclusive}). This result also establishes the fact that in \ac{ACCPL} rendering conflicting decisions is not possible. 

\lstset{language=Coq, frame=single, caption={\syn{Permitted} and \syn{NotPermitted}: Mutually Exclusive},label={lst:permandnotpermmutualexclusive}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem trans_agreement_not_Perm_and_NotPerm_at_once:
  forall
  (e:environment)(ag:agreement)(action_from_query:act)
   (subject_from_query:subject)(asset_from_query:asset),


 ~((isResultInQueryResult 
    (Result Permitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query)) 
/\

 (isResultInQueryResult 
    (Result NotPermitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query))).

\end{lstlisting}
%\end{minipage}

The proof for the next theorem \syn{trans_agreement_not_NotPerm_and_not_Perm \newline _implies_Unregulated_dec} shows that in the case where neither a \syn{Permitted} nor \syn{NotPermitted} result exists in the set returned by \syn{trans_agreement}, there does exist at least one \syn{Unregulated} result (see listing~\ref{lst:notpermandnotpermimpliesunregulated}).

\lstset{language=Coq, frame=single, caption={Not (\syn{Permitted} and \syn{NotPermitted}) Implies \syn{Unregulated}},label={lst:notpermandnotpermimpliesunregulated}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}

Theorem trans_agreement_not_NotPerm_and_not_Perm_implies_Unregulated_dec:
  forall
    (e:environment)(ag:agreement)(action_from_query:act)
    (subject_from_query:subject)(asset_from_query:asset),

    (~(isResultInQueryResult 
      (Result Permitted subject_from_query action_from_query asset_from_query)
        (trans_agreement e ag action_from_query subject_from_query asset_from_query)) /\

    ~(isResultInQueryResult 
      (Result NotPermitted subject_from_query action_from_query asset_from_query)
        (trans_agreement e ag action_from_query subject_from_query asset_from_query))) ->

   (isResultInQueryResult 
      (Result Unregulated subject_from_query action_from_query asset_from_query)
       (trans_agreement e ag action_from_query subject_from_query asset_from_query)).
\end{lstlisting}
%\end{minipage}


\section{Decidable As An Inductive Predicate}

We encode the cases discussed in section~\ref{sec:maintheorems} in an inductively defined predicate called \syn{decidable} in listing~\ref{lst:inductivepredicatedecidablecoq}. Recall that the nonempty list that the agreement translation function \syn{trans_agreement} returns will return a set of results one per each \syn{primPolicy}.There are three cases. First when there is a \syn{NotPermitted} result in the set, second when there is a \syn{Permitted} result in the set, and third when there are no \syn{Permitted} and no \syn{NotPermitted} results in the set. We encode these three cases in three constructors for the type decidable. The constructors are: \syn{Denied}, \syn{Granted} and \syn{NotApplicable}.

\lstset{language=Coq, frame=single, caption={Inductive Predicate decidable},label={lst:inductivepredicatedecidablecoq}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}

Inductive decidable : environment -> agreement -> act -> subject -> asset -> Prop :=

     | Denied : forall
  (e:environment)(ag:agreement)(action_from_query:act)
   (subject_from_query:subject)(asset_from_query:asset), 

 (isResultInQueryResult 
    (Result NotPermitted subject_from_query action_from_query asset_from_query)
       (trans_agreement e ag action_from_query subject_from_query asset_from_query)) 
  -> decidable e ag action_from_query subject_from_query asset_from_query

     | Granted : forall
  (e:environment)(ag:agreement)(action_from_query:act)
   (subject_from_query:subject)(asset_from_query:asset), 
 (isResultInQueryResult 
    (Result Permitted subject_from_query action_from_query asset_from_query)
       (trans_agreement e ag action_from_query subject_from_query asset_from_query)) 
  -> decidable e ag action_from_query subject_from_query asset_from_query

     | NonApplicable : forall
  (e:environment)(ag:agreement)(action_from_query:act)
   (subject_from_query:subject)(asset_from_query:asset), 

  ~(isResultInQueryResult 
    (Result Permitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query)) 
     ->
  ~(isResultInQueryResult 
    (Result NotPermitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query)) 
  -> decidable e ag action_from_query subject_from_query asset_from_query.
\end{lstlisting}
%\end{minipage}


We declare and prove the decidability of \ac{ACCPL} in terms of the ``decidable'' predicate as seen in listing~\ref{lst:decidabletypecoq}. The proof is made simple since we use the previously proven theorem \syn{trans_agreement_dec2}. We will list the intermediate theorems that we have declared and proved which are used in the proof of theorem \syn{trans_agreement_dec2} and subsequent proofs in section~\ref{sec:intermediatetheorems}.

\lstset{language=Coq, frame=single, caption={Decidability Of Agreement Translation},label={lst:decidabletypecoq}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem trans_agreement_decidable:
  forall
  (e:environment)(ag:agreement)(action_from_query:act)
   (subject_from_query:subject)(asset_from_query:asset),
     decidable e ag action_from_query subject_from_query asset_from_query.
Proof.

intros e ag action_from_query subject_from_query asset_from_query.
specialize trans_agreement_dec2 with 
   e ag action_from_query subject_from_query asset_from_query.
intros H. destruct H as [H1 | H2].
apply Granted. assumption.
destruct H2 as [H21 | H22].
apply Denied. assumption.
apply NonApplicable. 
destruct H22 as [H221 H222].
exact H221.
destruct H22 as [H221 H222].
exact H222.
Defined.

\end{lstlisting}
%\end{minipage}

 
\section{ACCPL in the Landscape of Policy-based Policy Languages}

Tschantz and Krishnamurthi~\cite{Tschantz} argue for the need for formal means to compare and contrast policy-based access-control languages and they present a set of properties to analyze the behaviour of policies in light of additional and/or explicit environmental facts, policy growth and policy decomposition. Tschantz and Krishnamurthi apply their properties to two core policy languages and compare the results. One of the core policy languages they present is a simplified \ac{xacml} and the other is Lithium~\cite{Halpern2008}. In the following sections we will describe Tschantz and Krishnamurthi's properties and evaluate \ac{ACCPL} with respect to these properties.

\section{Reasonability Properties}\label{sec:threeinterpretations}

The properties Tschantz and Krishnamurthi~\cite{Tschantz} present revolve around three questions:

\begin{enumerate}
\item How decisions change when the environment has more facts
\item Impact of policy growth on how decisions may change
\item How amenable policies are to compositional reasoning
\end{enumerate}

Tschantz and Krishnamurthi~\cite{Tschantz} use a simple policy as a motivating example (which they attribute to~\cite{Halpern2008}) that we will adapt and reuse here. The example will help to review the range of interpretations possible and ultimately the range of policy language design choices and where \ac{ACCPL} is on that range.
The policy in English is as follows:

\begin{itemize}
\item If the subject has a subscription to the Gold bundle, then permit that subject to print TheReport.

\item If the subject has a subscription to the Basic bundle, then do not permit that subject to print TheReport.

\item If the subject has no subscription to the Gold bundle, then permit that subject to play Terminator.
\end{itemize}

Consider a query and a fact in English as: A subscriber to the Basic bundle requests to play the movie Terminator. Let`s extract the fact that the subject is a subscriber to the Basic bundle into a separate term and make it part of the environment. The basic policy, the query in question and the environment are all expressed as a (pseudo) logic formula and listed in the listing~\ref{lst:basicpolicyAST}. Should the access query be granted?

\lstset{mathescape, language=AST}  
\begin{lstlisting}[frame=single, caption={Basic Policy},label={lst:basicpolicyAST}]

p1 = GoldBundle(s) -> Permitted(s, print, TheReport) 
p2 = BasicBundle(s) -> NotPermitted(s, print, TheReport) 
p3 = ~GoldBundle(s) -> Permitted(s, play, Terminator)
q1 = (s, play, Terminator) 
e1 = BasicBundle(s)
\end{lstlisting}


According to Tschantz and Krishnamurthi~\cite{Tschantz} at least three different interpretations are possible. We will list the possibilities and then evaluate how \ac{ACCPL} would answer the query.

\begin{itemize}
\item Implicit: Grant access because of \syn{p3}. This interpretation assumes that if a subject has a subscription to the Basic bundle, the subject does not have a subscription to the Gold bundle so the assumption is that there is a proof for \syn{~GoldBundle(s)}. This is an example of ``implicit'' knowledge and ``closed world assumptions''.

\item Explicit: The policy does not apply to the query. In other words, the query is ``NotApplicable''. \syn{p1} and \syn{p2} don't apply since the asset and the action in the request don't match the ones in \syn{p1} and \syn{p2}. \syn{p3} does not apply either since no proof exists to show that \syn{~GoldBundle(s)}. 

\item Implicit with automatic proof capability: grants access to the query by automatically proving that \syn{~GoldBundle(s)}. Under this interpretation, proof by contradiction is used to establish \syn{~GoldBundle(s)}.  The assumption \syn{GoldBundle(s)} is added to \syn{e1} which already contains \syn{BasicBundle(s)}. Now \syn{p1} permits TheReport to be printed by the subject while \syn{p2} would not permit TheReport to be printed by the subject, leading to a contradiction and the proof of \syn{~GoldBundle(s)}.
\end{itemize}

A policy language based on the first and third interpretations are not certifiable, meaning a machine-checked proof of the correctness of their semantics with respect to different properties (such as decidability) may not be possible. The main problem with such languages is the implicitness of their semantics. This was the case for the Pucella and Weissman~\cite{pucella2006} fragment of \ac{odrl}; although the interpretation found in Pucella and Weissman's fragment doesn't necessarily match the first and the third interpretations above, they are certainly in the camp of ``implicit'' interpretations. \ac{ACCPL} matches the second interpretation in the sense of having explicit semantics which leads to certifiably results we discuss elsewhere.


\section{Policy Based Access-Control Languages}

Tschantz and Krishnamurthi~\cite{Tschantz} define an access-control policy language as a tuple $L = (P, Q, G, N, \left\langle\left\langle . \right\rangle\right\rangle)$ where $P$ is a set of policies, $Q$ is a set of requests or queries, $G$ is the granting decisions, $N$ is the non-granting decisions, $\left\langle\left\langle . \right\rangle\right\rangle$ is a function taking a policy $p \in P$ to a relation between $Q$ and $G \cup N$ where $G \cap N = \emptyset$. Let $D$ represent $G \cup N$. Policy $p$ assigns a decision of $d \in D$ to the query $q \in Q$. $L$ also defines a partial order on decisions such that $d \leq d'$ if either $d, d' \in N$ or $d, d' \in G$ or $d \in N$ and $d' \in G$. Note that for \ac{ACCPL}, $D = \left\{ {Unregulated, NotPermitted, Permitted}\right\}$, $G = \left\{ {Permitted}\right\}$ and $N = \left\{ {Unregulated, NotPermitted}\right\}$.


\section{Policy Combinators}\label{sec:policycombinators}

Primitive policies are often developed by independent entities within an organization therefore it is natural to want a way of combining them into a policy for the whole organization using policy combinators. Some languages such as \ac{odrl} have nested sub-policies inside other policies. In such cases one design decision could be to allow for different combinators for different layers to make the language more expressive. Some examples of policy combinators are: conjunction, disjunction, exclusive disjunction, \syn{Permitted} override (if any of the primitive policies returns a \syn{Permitted}, return only \syn{Permitted}), \syn{NotPermitted} override (if any of the primitive policies returns a \syn{NotPermitted}, return only \syn{NotPermitted})~\cite{Tschantz}.

\section{ACCPL}

When designing \ac{ACCPL} and to make the decidability proofs possible, we sought out all the different combinations and cases possible (through interaction with the proof process) and explicitly enumerated them in the translation functions. Once we made explicit all the different cases where a decision was possible, we assigned \syn{Permitted} and \syn{NotPermitted} decisions to two specific cases while every other enumerated case was rendered with an \syn{Unregulated} (not applicable) decision. Explicit enumeration of all the different cases has been certified to be complete by the fact that we have the decidability results. Note that we could have made different design choices in assigning the decisions. 

For example, we could have replaced all or some of the current \syn{Unregulated} decision assignments to either \syn{Permitted} or \syn{NotPermitted} depending on whether we want to make the language more permissive or more prohibitive. Note if we were to implement the changes proposed here, the current decidability results would no longer hold and the \syn{Unregulated} case would have to be removed from the statement of the theorem and the theorem statement to be modified to look like the theorem listed in listing~\ref{lst:agreementdecidablecoqSecond}.

\lstset{language=Coq, frame=single, caption={Agreement Translation is Decidable (for \syn{Permitted} or \syn{NotPermitted} only)},label={lst:agreementdecidablecoqSecond}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem trans_agreement_dec:
  forall
  (e:environment)(ag:agreement)(action_from_query:act)
   (subject_from_query:subject)(asset_from_query:asset),

 (isResultInQueryResult 
    (Result Permitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query)) 
\/
 (isResultInQueryResult 
    (Result NotPermitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query)).

\end{lstlisting}
\end{minipage}



\section{Deterministic and Total}

According to Tschantz and Krishnamurthi~\cite{Tschantz} a language $L$ is defined to be deterministic if $forall$ $p \in P$, $forall$ $q \in Q$, $forall$ $d, d' \in D$, $q \left\langle\left\langle p  \right\rangle\right\rangle d$ $\land$ $q \left\langle\left\langle p  \right\rangle\right\rangle d'$ $\implies$ $d = d'$. In words, the definition states that for a deterministic language, given a query and a policy, if the policy translation renders a decision of $d$ and a decision of $d'$, then the two decisions must be the same.

A language $L$ is total if $forall$ $p \in P$, $forall$ $q \in Q$, $exists$ $d \in D$, s.t. $q \left\langle\left\langle p  \right\rangle\right\rangle d$. In words, for a total language, the policy translation always renders a decision.

We conjecture that \ac{ACCPL} is both deterministic and total. We defer the proof of determinism of \ac{ACCPL} to future work. As for \ac{ACCPL} being a total language we believe the fact that \ac{ACCPL} is decidable (see listing~\ref{lst:decidabletypecoq}) implies \ac{ACCPL} is a total language. We defer the detailed declaration and proof of totality of \ac{ACCPL} to future work.

\section{Safety}

As discussed in section~\ref{sec:threeinterpretations} policy interpretations could be implicit or explicit. Explicit interpretations distinguish between unknown information and information known to be absent. The explicit approach promotes verbose policies and requests and usually leads to too many \syn{Unregulated} or NotApplicable decisions (in the absence of the right environmental facts). However the verbosity could be used to direct what additional facts are needed to make a granting and denying decision. Under the second interpretation in~\ref{sec:threeinterpretations} while the decision is NotApplicable, the system can direct the entity making the request provide a proof of \syn{~GoldBundle(s)} in order for a granting decision to be rendered. 

Implicit interpretations may result in granting unintended access to protected resources because no explicit facts need be mentioned in the environment. Recall that the implicit approach works by making assumptions when facts are not explicitly mentioned. Such unintended assumptions lead to unintended permissions being granted.

Tschantz and Krishnamurthi~\cite{Tschantz} define safety as $forall$ $p \in P$, $forall$ $q, q' \in Q$, \\$q$ $\leq$ $q'$ $\implies$ $q \left\langle\left\langle p  \right\rangle\right\rangle d$ $\leq$ $q \left\langle\left\langle p  \right\rangle\right\rangle d'$ which intuitively says that policies written in a safe language $L$, will not result in the leakage of permissions to unintended subjects. For example, incomplete information may unintentionally cause an access permission to be granted to an intruder. 

Could we conclude that an access-control policy language with the explicit approach such as \ac{ACCPL} is also safe? in the design of \ac{ACCPL} and the translation functions in particular we only grant or deny access in specific cases. We grant access if the asset and the action in query are found in the agreement and \syn{trans_prin} has a proof and \syn{trans_preRequisite} for both policy set and policy have proofs. We deny an access request if the policy set is an exclusive policy set (\syn{primExclusivePolicySet}) and \syn{trans_prin} does not hold. In all other cases we render the decision of \syn{Unregulated}. In other words, in the absence of necessary facts (proofs), we give the least decision (e.g. \syn{Unregulated}), when there are more facts available in the environment (such as \syn{trans_preRequisite} holding), we grant either deny or permit decisions. However when all the facts hold, corresponding to the greatest query in the definition of safety, we render a granting decision which is also the greatest decision in the lattice of decisions: \syn{Unregulated} $\leq$ \syn{NotPermitted} $\leq$ \syn{Permitted}.


\section{Independent Composition}

As discussed in section~\ref{sec:threeinterpretations}, the third interpretation works by taking into account not only the third policy, $p3$, but also $p1$ and $p2$ to render a decision of granted. However each of the policies in isolation would result in the NotApplicable decision. 

Taking into account all policies and rendering a decision that is not different from combining the decisions reached by each primitive policy in isolation, is a property called ``Independent Composition'' by Tschantz and Krishnamurthi~\cite{Tschantz}. The third interpretation in section~\ref{sec:threeinterpretations} is clearly not have this property. Formally, a language $L$ has the independent composition property, if $forall$ $p \in P$, $forall$ $q \in Q$, $forall$ $d, d^\ast \in D$, \\$\boxplus$ ($q \left\langle\left\langle p_{1}  \right\rangle\right\rangle d_{1}$, $q \left\langle\left\langle p_{2}  \right\rangle\right\rangle d_{2}$, ..., $q \left\langle\left\langle p_{n}  \right\rangle\right\rangle d_{n}$) $=$ $q \left\langle\left\langle (\oplus p_{1}, p_{2}, ..., p_{n}) \right\rangle\right\rangle d^\ast$, where $\oplus$ is a composition operator defined in the language and $\boxplus$ is the decision composition operator. For this definition to be well-defined, there is a requirement that complete environmental facts be available for each individual policy so that a decision can be rendered for each primitive policy with respect to the request, in isolation.

Does \ac{ACCPL} have the independent composition property? As covered in chapter~\ref{chap:accplsemanticscoq} and section~\ref{sec:policycombinators} the translation functions for \ac{ACCPL}, starting with \syn{trans_agreement} all return sets of \syn{result}s.  The set of \syn{result}s returned by the agreement translation function will have a result per \syn{primPolicy} (type of primitive policies) in the agreement. Recall that results containing a \syn{Permitted} answer and a \syn{NotPermitted} answer are mutually exclusive and the existence of a single (or more) \syn{Permitted} result in the set makes the whole set ``Permitted'' whereas the existence of a single (or more) \syn{NotPermitted} result makes the whole set ``NotPermitted''. When no \syn{Permitted} or \syn{NotPermitted} is seen in the set, we only have \syn{Unregulated} results which would make the whole set ``Unregulated". This is the decision combination strategy we have designed for \ac{ACCPL}; the policy combination strategy \ac{ACCPL} simply preserves all individual decisions and returns the whole set for rendering a global decision. Below we consider the three different possible decisions that the decision combination strategy may reach and review whether the result of any individual policy may change as a result.

\begin{enumerate}
  \item Global decision is \syn{Permitted}. Only possible results are \syn{Permitted} or \syn{Unregulated}. In this case, only the \syn{Unregulated} results have been modified by the decision combination strategy. \syn{Permitted} results coming from any individual primitive policy will have been preserved.
  \item Global decision is \syn{NotPermitted}. Only possible results are \syn{NotPermitted} or \syn{Unregulated}. In this case, similar to the first case, only the \syn{Unregulated} results have been modified by the decision combination strategy. \syn{NotPermitted} results coming from any individual primitive policy will have been preserved.
   \item Global decision is \syn{Unregulated}. Only possible results are \syn{Unregulated}.  In this case, results coming from any individual primitive policy will have been preserved.
\end{enumerate}

We argue that \ac{ACCPL} has the independent composition property with respect to granting and denying policies only as detailed in the previous paragraphs. 

\section{Monotonicity of Policy Combinators}

Tschantz and Krishnamurthi~\cite{Tschantz} discuss the notion of monotonicity of policy combinators. Intuitively, in a language with a policy combinator that is monotonic, adding another primitive policy, cannot change the combined decision to go from grating to non-granting. In \ac{ACCPL}, NotApplicable results are only possible if \syn{trans_prin} does not hold. Assume the combined (global) decision is already \syn{Permitted} for a certain agreement. In the case when \syn{trans_prin} does not hold, adding a primitive policy to the agreement will not change the \syn{Permitted} result to a \syn{NotPermitted} result, since a primitive policy is composed of a \syn{preRequisite} and an \syn{act} only. In the case where \syn{trans_prin} does hold, there are two cases. Either the \syn{preRequisite} of the added policy holds and the decision is another \syn{Permitted} result, or the \syn{preRequisite} of the added policy does not hold, and the decision is an \syn{Unregulated} which won't affect the combined decision.





\section{Intermediate Theorems}\label{sec:intermediatetheorems}
The theorem \syn{trans_agreement_dec_sb_Permitted} states as a sumbool that the nonempty list that \syn{trans_agreement} produces, contains a \syn{Permitted} result or not and this is decidable (see listing~\ref{lst:decsbpermitted}).


\lstset{language=Coq, frame=single, caption={Translation Function for Agreement Returns a \syn{Permitted} result or Not},label={lst:decsbpermitted}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem trans_agreement_dec_sb_Permitted:
  forall
  (e:environment)(ag:agreement)(action_from_query:act)
   (subject_from_query:subject)(asset_from_query:asset),


 {(isResultInQueryResult 
    (Result Permitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query))} +
 {~(isResultInQueryResult 
    (Result Permitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query))}.

\end{lstlisting}
%\end{minipage}

The theorem \syn{trans_agreement_dec_sb_NotPermitted} states as a sumbool that the nonempty list that \syn{trans_agreement} produces, contains a \syn{NotPermitted} result or not and this is decidable (see listing~\ref{lst:decsbnotpermitted}).

\lstset{language=Coq, frame=single, caption={Translation Function for Agreement Returns a \syn{NotPermitted} result or Not},label={lst:decsbnotpermitted}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem trans_agreement_dec_sb_NotPermitted:
  forall
  (e:environment)(ag:agreement)(action_from_query:act)
   (subject_from_query:subject)(asset_from_query:asset),

 {(isResultInQueryResult 
    (Result NotPermitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query))} +
 {~(isResultInQueryResult 
    (Result NotPermitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query))}.

\end{lstlisting}
%\end{minipage}

The theorem \syn{resultInQueryResult_dec} states as a sumbool that a given result is either in the nonempty list of \syn{results} or not and this is decidable (see listing~\ref{lst:decresultInResults}).

\lstset{language=Coq, frame=single, caption={Result is in Results or Not},label={lst:decresultInResults}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem resultInQueryResult_dec :
    forall (res:result)(results: nonemptylist result), 
 {isResultInQueryResult res results} + {~isResultInQueryResult res results}.
\end{lstlisting}
%\end{minipage}

The theorem \syn{trans_agreement_not_Perm_and_NotPerm_at_once} states that you may not have both a \syn{Permitted} and \syn{NotPermitted} result in the nonempty list that \syn{trans_agreement} produces (see listing~\ref{lst:permandnotpermatonce}).

\lstset{language=Coq, frame=single, caption={Translation Function for Agreement will not have both \syn{Permitted} and \syn{NotPermitted}},label={lst:permandnotpermatonce}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem trans_agreement_not_Perm_and_NotPerm_at_once:
  forall
  (e:environment)(ag:agreement)(action_from_query:act)
   (subject_from_query:subject)(asset_from_query:asset),


 ~((isResultInQueryResult 
    (Result Permitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query)) 
/\

 (isResultInQueryResult 
    (Result NotPermitted subject_from_query action_from_query asset_from_query)
    (trans_agreement e ag action_from_query subject_from_query asset_from_query))).

\end{lstlisting}
%\end{minipage}

The theorem \syn{trans_policy_PIPS_dec_not} states that the translation function trans_policy_PIPS produces a nonempty list of results that will not have a \syn{NotPermitted} result. This makes intuitive sense as \syn{trans_policy_PIPS} is called for inclusive policy sets only (see listing~\ref{lst:pipsdecnot}).
\lstset{language=Coq, frame=single, caption={Translation Function for PIPS will not return a \syn{NotPermitted} result},label={lst:pipsdecnot}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem trans_policy_PIPS_dec_not:
  forall
  (e:environment)(prq: preRequisite)(p:policy)(subject_from_query:subject)
  (prin_u:prin)(a:asset)(action_from_query:act),

 ~(isResultInQueryResult 
    (Result NotPermitted subject_from_query action_from_query a)
    (trans_policy_PIPS e prq p subject_from_query prin_u a action_from_query)).

\end{lstlisting}
%\end{minipage}

The theorem \syn{trans_policy_PEPS_perm_implies_not_notPerm_dec} states that having a \syn{Permitted} result in the nonempty list of results that the translation function trans_policy_PEPS produces implies there exists no \syn{NotPermitted} result in the nonempty list (see listing~\ref{lst:pepspermimpliesnotperm}).

\lstset{language=Coq, frame=single, caption={\syn{Permitted} in results by Translation Function for PEPS implies no \syn{NotPermitted}},label={lst:pepspermimpliesnotperm}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem trans_policy_PEPS_perm_implies_not_notPerm_dec:
  forall
  (e:environment)(prq: preRequisite)(p:policy)(subject_from_query:subject)
  (prin_u:prin)(a:asset)(action_from_query:act),

    (isResultInQueryResult 
      (Result Permitted subject_from_query action_from_query a)
        (trans_policy_PEPS e prq p subject_from_query prin_u a action_from_query)) ->

   ~(isResultInQueryResult 
      (Result NotPermitted subject_from_query action_from_query a)
       (trans_policy_PEPS e prq p subject_from_query prin_u a action_from_query)).

\end{lstlisting}
%\end{minipage}
The theorem AnswersNotEqual states that two answers not being equal implies that results built from those answers are not equal as well (see listing~\ref{lst:answersnotequal}).

\lstset{language=Coq, frame=single, caption={Non Equal Answers Give Non Equal Results},label={lst:answersnotequal}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem AnswersNotEqual: forall (ans1:answer)(ans2:answer)(s:subject)(ac:act)(ass:asset),
  (ans1<>ans2) -> ((Result ans1 s ac ass) <> (Result ans2 s ac ass)).

\end{lstlisting}
%\end{minipage}

The theorem \syn{trans_policy_positive_dec_not} states that the translation function trans_policy_positive produces a nonempty list of results that will not have a \syn{NotPermitted} result (see listing~\ref{lst:positivedecnot}).


\lstset{language=Coq, frame=single, caption={Translation Function for Permitting Policies will not return a \syn{NotPermitted} result},label={lst:positivedecnot}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}

Theorem trans_policy_positive_dec_not:
  forall 
(e:environment)(s:subject)(p:policy)(prin_u:prin)(a:asset)
  (action_from_query: act),
 
  ~(isResultInQueryResult 
    (Result NotPermitted s action_from_query a)
    (trans_policy_positive e s p prin_u a action_from_query)).
\end{lstlisting}
%\end{minipage}

The theorem \syn{trans_policy_negative_dec_not} states that the translation function trans_policy_negative produces a nonempty list of results that will not have a \syn{Permitted} result (see listing~\ref{lst:negativedecnot}).

\lstset{language=Coq, frame=single, caption={Translation Function for NotPermitting Policies will not return a \syn{Permitted} result},label={lst:negativedecnot}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem trans_policy_negative_dec_not:
  forall 
(e:environment)(s:subject)(p:policy)(a:asset)
  (action_from_query: act),
 
  ~(isResultInQueryResult 
    (Result Permitted s action_from_query a)
    (trans_policy_negative e s p a action_from_query)).

\end{lstlisting}
%\end{minipage}

The theorem \syn{trans_policy_unregulated_dec_not} states that the translation function trans_policy_unregulated produces a nonempty list of results that will not have a \syn{Permitted} nor a \syn{NotPermitted} result (see listing~\ref{lst:unregulateddecnot}).

\lstset{language=Coq, frame=single, caption={Translation Function for \syn{Unregulated} Requests will not return \syn{Permitted} nor \syn{NotPermitted}},label={lst:unregulateddecnot}}

%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem trans_policy_unregulated_dec_not:
  forall 
(e:environment)(s:subject)(p:policy)(a:asset)
  (action_from_query: act),
 
  ~(isResultInQueryResult 
    (Result Permitted s action_from_query a)
    (trans_policy_unregulated e s p a action_from_query)) /\
  
  ~(isResultInQueryResult 
    (Result NotPermitted s action_from_query a)
    (trans_policy_unregulated e s p a action_from_query)).
\end{lstlisting}
%\end{minipage}















