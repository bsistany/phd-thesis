%======================================================================
\chapter{ACCPL Syntax In Coq}\label{chap:odrl0syntaxcoq}
%======================================================================

% ---------------------------------- COQ -----------------------
\section{Introduction to Coq}

Coq is known first and foremost as a proof-assistant. The underlying formal language that Coq uses is a much more expressive version of typed lambda calculus called \ac{cic} where proofs and programs can both be represented. For example, \ac{cic} adds polymorphism (terms depending on types), type operators (types depending on types) and dependent types (types depending on terms).

Specifications of programs in Coq may be expressed using the specification language \emph{Gallina}~\cite{gallinaref}. Coq is then used to develop proofs to show that a program's run-time behaviour satisfies its specification. Such programs are called \emph{certified} because they are formally verified and confirmed to conform to their specifications~\cite{BC04}.

Assertions or propositions are statements about values in Coq such as $3<8$ or $8<3$ that may be true, false or even be only conjectures. To verify that a proposition is true a proof needs to constructed. While paper-proofs use a combination of mathematics and natural language to describe their proofs, Coq provides a formal (and therefore unambiguous) language that is based on proof-theory to develop proofs in. Verification of complex proofs is possible because one can verify the intermediate proofs or sub-goals in steps, each step being derived from the previous by following precise derivation rules. The Coq proof engine solves successive goals by using predefined \emph{tactics}. Coq tactics are commands to manipulate the local context and to decompose a goal into simpler goals or sub-goals~\cite{BC04}.

\section{ACCPL Syntax}\label{sec:agreementConstructor}

\ac{ACCPL} productions were presented as high level abstract syntax in section~\ref{sec:productionast} of chapter~\ref{chap:odrl0syntax}. Below we present the corresponding encodings in Coq. 

An agreement is a new inductive type in Coq by the same name. The constructor $Agreement$ takes a $prin$, an $asset$ and a $policySet$. $prin$ is defined to be a nonempty list of $subject$s (see listing~\ref{lst:agreementcoq}). 

\ac{ACCPL} types $asset$, $subject$, $act$ and $policyId$ are base types and are simply defined as $nat$ which is the datatype of natural numbers defined in coq's library module $Coq.Init.Datatypes$ ($nat$ is itself an inductive datatype). We use Coq constants to refer to specific objects of each type. For example, the subject 'Alice' is defined as $Definition Alice:subject := 101.$ and the act 'Play' as $Definition Play : act := 301.$. For each ``nat'' type in \ac{ACCPL} we have also used constants that play the role of ``Null'' objects (see ``Null Object Pattern''~\cite{martin1998pattern}), for example $NullSubject$ is defined as $Definition NullSubject:subject := 100.$. This means a specific natural number has been selected as a ``reserved'' number for each \ac{ACCPL} base type to play the role of a ``Null'' value. ``Null'' values are needed because all the sequence types in \ac{ACCPL} are defined to be non-empty sequences (implemented using the $nonemptylist$ datatype) even though at intermediate stages during the translation the concept of an empty list is needed. In such cases, a Null object is created and added to the nonempty list.

Next we define the $policySet$ datatype which is the direct implementation of the abstract syntax presented in listing~\ref{lst:policySetast}. A $policySet$ is constructed only one way: by calling the $PPS$ constructor which takes a $primPolicySet$ as input. There are two ways a $primPolicySet$ can be constructed (see listing~\ref{lst:primPolicySetast} for the abstract syntax version) corresponding to two constructors: $PIPS$ and $PEPS$. 

$PIPS$ takes a $primInclusivePolicySet$ as input while $PEPS$ takes a $\linebreak primExclusivePolicySet$. Both  $primInclusivePolicySet$ and $primExclusivePolicySet$ types are constructed by taking a $preRequisite$ and a $policy$ as parameters (see listing~\ref{lst:primInclusivePolicySetast} and ~\ref{lst:primExclusivePolicySetast} for the abstract syntax versions). 

A $policy$ is defined as a datatype with the constructors $Policy$ which takes a nonempty list of primitive policies, or $primPolicy$s. A $primPolicy$ is constructed by calling $\linebreak PrimitivePolicy$ which takes a $preRequisite$, a $policyId$ and an action $act$ (see listing~\ref{lst:primPolicyast} for the abstract syntax version). Ignoring the $policyId$ for a moment, a primitive policy consists of a prerequisite and an action. If the prerequisite holds, the action is allowed to be performed on the asset. 


\lstset{language=Coq}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={ACCPL: Coq Version of Agreement},label={lst:agreementcoq}]
Inductive agreement : Set :=
  | Agreement : prin -> asset -> policySet -> agreement.

Definition prin := nonemptylist subject.

Definition asset := nat.

Definition subject := nat.

Definition act := nat.

Definition policyId := nat.

Inductive policySet : Set :=
  | PPS : primPolicySet -> policySet.
  
Inductive primPolicySet : Set :=
  | PIPS : primInclusivePolicySet -> primPolicySet
  | PEPS : primExclusivePolicySet -> primPolicySet.

Inductive primInclusivePolicySet : Set :=
  | PrimitiveInclusivePolicySet : preRequisite -> policy -> primInclusivePolicySet.

Inductive primExclusivePolicySet : Set :=
  | PrimitiveExclusivePolicySet : preRequisite -> policy  -> primExclusivePolicySet.

Inductive policy : Set :=
  | Policy : nonemptylist primPolicy -> policy.

Inductive primPolicy : Set :=
  | PrimitivePolicy : preRequisite -> policyId -> act -> primPolicy.

\end{lstlisting}
\end{minipage}

The data type $nonemptylist$ reflects the definition of ``policy conjunction'' (see the definition of $nonemptylist$ in listing~\ref{lst:nonemptylistcoq}). Essentially $nonemptylist$ represents a list data structure that has at least one element and it is defined as a new \emph{polymorphic} inductive type in its own Coq section. See the abstract syntax version of $nonemptylist$ in listing~\ref{lst:policyast}.  


\lstset{language=Coq, frame=single, caption={nonemptylist},label={lst:nonemptylistcoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}

Section nonemptylist.

Variable X : Set.

Inductive nonemptylist : Set :=
  | Single : X -> nonemptylist 
  | NewList : X -> nonemptylist -> nonemptylist.

End nonemptylist.
\end{lstlisting}
\end{minipage}


In listing~\ref{lst:preRequisitecoq} $preRequisite$ is defined as a new datatype with constructors $TruePrq$, $Constraint$, $NotCons$ and $AndPrqs$ (see listing~\ref{lst:preRequisiteast} for the abstract syntax equivalent).

$TruePrq$ represents the always true prerequisite. The $Constraint$ prerequisite is defined as the type $constraint$ so its description is deferred here. Intuitively a constraint is a prerequisite to be satisfied that is outside the control of the user(s). For example, the constraint of being 'Alice' if you are 'Bob' (or 'Alice' for that matter). The constructor $NotCons$ is defined the same way the $Constraint" constructor$ is. This constructor is defined as the type $constraint$ and it is meant to represent the negation of a $constraint$ as we shall see in the translation (see listing~\ref{lst:transnotConsCoq}). The remaining constructor $AndPrqs$ takes as parameters nonempty lists of prerequisites. This constructor represents the conjunction combining operator. 

Finally a $constraint$ (see  listing~\ref{lst:constraintast} for the abstract syntax equivalent) is defined as a new datatype with constructors $Principal$, $Count$ and $CountByPrin$. 

Principal constraint takes a $prin$ to match. For example, the constraint of the user being Bob would be represented as ``Principal constraint''. The $Count$ constructor takes a $nat$ which represents the number of times the user of an agreement has invoked the corresponding policies to justify her actions. If the count constraint is part of a policy then the corresponding policies is basically the single policy, whereas in the case that the count constraint is part of a policy set, the corresponding policies would be the set of those policies specified in the policy set. The $CountByPrin$ is similar to $Count$ but it takes an additional $prin$ parameter. In this case the subjects specified in the $prin$ parameter override the agreements' user(s).   

% prq
\lstset{language=Coq}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={preRequisite},label={lst:preRequisitecoq}]
Inductive preRequisite : Set :=
  | TruePrq : preRequisite
  | Constraint : constraint -> preRequisite 
  | NotCons : constraint -> preRequisite 
  | AndPrqs : nonemptylist preRequisite -> preRequisite.
  
  
Inductive constraint : Set :=
  | Principal : prin  -> constraint 
  | Count : nat -> constraint 
  | CountByPrin : prin -> nat -> constraint.

\end{lstlisting}
\end{minipage}

We started with the encoding of the agreement for Alice and Bob in chapter~\ref{chap:odrl0syntax} but we deferred the definition of the Coq constructs used to define that agreement. All the definitions needed to encode the agreement for Alice and Bob have now been defined so we show how that agreement looks like in \ac{ACCPL} in the listing~\ref{lst:agreementAliceAndBob}. We also repeat the listing of the agreement using the syntax from~\cite{pucella2006} from chapter~\ref{chap:odrl0syntax} in the listing~\ref{lst:agreementpucella2006two}.

\lstset{language=Pucella2006}
\begin{lstlisting}[frame=single, caption={Agreement for Alice and Bob as BNF},label={lst:agreementpucella2006two}]
agreement
 for Alice and Bob 
 about The Report 
 with True -> and[count[5] => print], and[Alice, count[2] => print].
\end{lstlisting}


\lstset{language=Coq}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={Agreement for Alice and Bob in \ac{ACCPL}},label={lst:agreementAliceAndBob}]

Definition p1A1:primPolicySet :=
  PIPS (PrimitiveInclusivePolicySet
    TruePrq
    (Policy (Single (PrimitivePolicy (Constraint (Count  5)) id1 Print)))).

Definition p2A1prq1:preRequisite := (Constraint (Principal (Single Alice))).
Definition p2A1prq2:preRequisite := (Constraint (Count 2)).

Definition p2A1:primPolicySet :=
  PIPS (PrimitiveInclusivePolicySet
    TruePrq
    (Policy 
      (Single 
        (PrimitivePolicy (AndPrqs (NewList p2A1prq1 (Single p2A1prq2))) id2 Print)))).


Definition A1 := Agreement (NewList Alice (Single Bob)) TheReport (PPS p1A1).
\end{lstlisting}	
%\end{minipage}	


