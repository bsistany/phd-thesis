%======================================================================
\chapter{ACCPL Semantics In Coq}\label{chap:accplsemanticscoq}
%======================================================================

% ---------------------------------- COQ -----------------------
We specify the semantics of \ac{ACCPL} as a translation function from an agreement together with an access request and an environment containing all relevant facts, to decisions (more concretely to a set of \syn{result}s--see listing~\ref{lst:answercoq}). Specifying the semantics as translations from an agreement, an access request and an environment to decisions, mostly follows the style Pucella and Weissman~\cite{pucella2006} use to define the semantics for their \ac{odrl} fragment. In Pucella and Weissman's language, the translation functions are defined from agreements to formulas in many-sorted \ac{fol} with equality. The translation functions for \ac{ACCPL} return a specific decision based on whether there are proof terms for certain conditions and/or proof terms for the negation of those conditions (see Section~\ref{sec:sumboolsection} for more details).
 

% COQ
The translation functions plus the auxiliary types and infrastructure which implement the semantics for \ac{ACCPL} have been encoded in Coq. The Coq code implementing the semantics is high-level enough to be readable as a specification of the semantics. This is one reason why we do not use abstract syntax to describe the semantics as we did for the syntax of \ac{ACCPL} (see chapter~\ref{chap:odrl0syntax}). The other reason not to use abstract syntax the way Pucella and Weissman~\cite{pucella2006} do for their semantics, is the difficulty of coming up with abstract syntax that is intuitive and equivalent to the translation functions implemented in Coq and listed in this chapter.

Whether an agreement and the accompanying access request or query is translated into a decision indicating a permission is granted or denied depends on the agreement in question and the specifics of the request, but also on the facts recorded in the environment (e.g. time of day). For \ac{ACCPL} those facts revolve around the number of times a policy has been used to justify an action. We encode this information in Coq as a new inductive type representing the environment. An \syn{environment} (see listing~\ref{lst:environmentcoq}) is a conjunction of equalities of the form \syn{count(s, policyId) = n} which are called ``count equalities'' (see Section~\ref{sec:odrl0} for background on environments).

% COQ
The Coq version of a count equality is a new inductive type called \syn{count_equality}. An environment is defined to be a non-empty list of \syn{count_equality} objects (see listing~\ref{lst:environmentcoq}). Function \syn{make_count_equality} in listing~\ref{lst:environmentcoq} is simply a convenience function that builds \syn{count_equality} objects. 

\lstset{language=Coq, frame=single, caption={Environments and Counts},label={lst:environmentcoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Inductive count_equality : Set := 
   | CountEquality : subject -> policyId -> nat -> count_equality.

Definition make_count_equality
  (s:subject)(id:policyId)(n:nat): count_equality :=
  CountEquality s id n.
  
Inductive environment : Set := 
  | SingleEnv : count_equality -> environment
  | ConsEnv :  count_equality ->  environment -> environment.

\end{lstlisting}
\end{minipage}

For an example of how environments are created see listing~\ref{lst:environmentusagecoq}.

\lstset{language=Coq, frame=single, caption={Defining Environments},label={lst:environmentusagecoq}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}

Definition e1 : environment := 
  (SingleEnv (make_count_equality Alice id1 8)).

\end{lstlisting}
%\end{minipage}
  

We also define a \syn{getCount} function that given a pair consisting of a subject and policy id, looks for a corresponding count in the environment. The \syn{getCount} function assumes the given environment is consistent (meaning it won't return two different counts for the same pair of subject and policy id), so it returns the first matched \syn{count} it sees for a \syn{(subject, id)} pair. If a \syn{count} for a \syn{(subject, id)} pair is not found it returns 0. 

We have defined the necessary representations in Coq in the form of an inductive predicate (called \syn{env_consistent}) to verify the consistency assumption mentioned above (see listing~\ref{lst:envsConsistentcoq}). For a given environment \syn{e1}, we would require a proof of the proposition ``\syn{env_consistent e1}'' before translation begins. Note that we have defined helper lemmas to help complete such proofs. In the listing~\ref{lst:envsConsistentcoq}, we have also shown the definition of the function \syn{inconsistent} which states that two \syn{count_equality} values are inconsistent for the same pair of subject and policy id, if the counts are different. Another helper definition shown in listing~\ref{lst:envsConsistentcoq} is the function \syn{formula_inconsistent_with_env} which captures the proposition ``this count formula is inconsistent with this environment''.

%Another option would be to restrict the environment type to a subset (consistent environments only) using Coq's \syn{sig} type defined in the Coq standard library module \syn{Coq.Init.Specif}. According to~\cite{Coq:manual} \syn{(sig A P)} or the notationally convenient \syn{\{x:A | P x\}}, represents the subset of elements of the type A which satisfy the predicate P. 

\lstset{language=Coq, frame=single, caption={Consistency of Environments},label={lst:envsConsistentcoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}

Inductive env_consistent : environment -> Prop :=
 | consis_1 : forall f, env_consistent (SingleEnv f)
 | consis_2 : forall f g, ~(inconsistent f g) -> env_consistent (ConsEnv f (SingleEnv g))
 | consis_more : forall f e,
    env_consistent e -> ~(formula_inconsistent_with_env f e) -> env_consistent (ConsEnv f e).

Definition inconsistent (f1 f2 : count_equality) : Prop :=
   match f1 with (CountEquality s1 id1 n1) =>
     match f2 with (CountEquality s2 id2 n2) =>
       s1 = s2 -> id1 = id2 -> n1 <> n2
     end
   end.

Fixpoint formula_inconsistent_with_env (f: count_equality)
			  (e : environment) : Prop :=
  match e with
    | SingleEnv g =>  inconsistent f g
    | ConsEnv g rest => (inconsistent f g) \/ (formula_inconsistent_with_env f rest)
  end.
\end{lstlisting}
\end{minipage}

\section{The \syn{sumbool} Type}\label{sec:sumboolsection}

\syn{sumbool} is a boolean type defined in the Coq standard library module \syn{Coq.Init.Specif}. The \syn{sumbool} type captures the idea of program values that indicate which of two propositions is true~\cite{chlipalacpdt2011}. The \syn{sumbool} type is equipped with the justification of their value~\cite{Coq:manual} which help with proofs. Using a tactic like \syn{destruct}~\cite{Coq:manual} two subgoals are generated, one for each form of the \syn{sumbool} instance, however the justifications also show up as hypothesis helping with discharging of the subgoals. The definition of \syn{sumbool} from Coq library module \syn{Coq.Init.Specif} is listed in listing~\ref{lst:sumbooltypeCoq}; notice the use of the \syn{where} clause in this listing, which allows notation to be simultaneously defined (and used) when presenting a new inductive definition.

\lstset{language=Coq, frame=single, caption={\syn{sumbool} type},label={lst:sumbooltypeCoq}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Inductive sumbool (A B:Prop) : Set :=
  | left : A -> {A} + {B}
  | right : B -> {A} + {B}
 where "{ A } + { B }" := (sumbool A B) : type_scope.
\end{lstlisting}
%\end{minipage}

As an example of how \syn{sumbool} type is used in the Coq standard library, see the listing~\ref{lst:sumboolofbooltypeCoq}, for the definition of the type \syn{sumbool_of_bool}. The definition in listing~\ref{lst:sumboolofbooltypeCoq} and the following description are taken from the library \syn{Coq.Bool.Sumbool}~\cite{Coq:manual}.
\begin{quote}
\syn{sumbool A B}, which is written \syn{A+B}, is the informative disjunction ``A or B'', where A and B are logical propositions. Its extraction is isomorphic to the type of booleans. A boolean is either true or false, and this is decidable. 
\end{quote}

\lstset{language=Coq, frame=single, caption={\syn{sumbool_of_bool} type},label={lst:sumboolofbooltypeCoq}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Definition sumbool_of_bool : forall b:bool, {b = true} + {b = false}.
\end{lstlisting}
%\end{minipage}
With \syn{sumbool}s similar to \syn{bool} and other 2-constructor inductive types, one can use the ``if then else'' construct to select the desired case when doing proofs which makes for much more readability of the given proofs.


We have used the \syn{sumbool} type to declare and prove decision procedures that we have subsequently used in the translation functions implementing the semantics and also in the proofs. We will list the decision procedures in Section~\ref{sec:decprocs} after reviewing the translation functions in Section~\ref{sec:translationfuncs}.


\section{Types of Decisions and their Implementation in Coq}\label{sec:answerandresulttypes}

Policy based access-control languages typically use a two-valued decision set to indicate whether an access request is granted or denied. When a decision for a query is not granted, one design choice for a language is to return an explicit deny decision. However in this case deny stands for ``not permitted''. It is possible to have cases when the policy truly doesn't specify either a permit or a deny decision. In such cases arbitrarily returning the decision of deny makes it difficult to compose policies and in fact, an explicit decision of ``non applicable'' is warranted in such cases. Some languages may decide to only support permit decisions. In such languages lack of a permit decision for a query signifies a deny decision so deny decisions are not explicit. Although the policies of these languages may be more readable than those with more explicit decisions, they result in ambiguity on whether a deny decision was really intended or not. Finally some languages define an explicit decision of ``error'' for cases such as when both permit and deny decisions are reached for the same query. An explicit error decision is preferable to undefined behaviour because it can lead to improvements to policies and/or how the queries are built~\cite{Tschantz}. 

Pucella and Weissman~\cite{pucella2006} employ a two-valued decision set where the granting decision is called \syn{Permitted} and the non-granting or denying decision is called \syn{NotPermitted}. In \ac{ACCPL} we have extended the decision set to be three-valued. We have added the \syn{Unregulated} decision to \syn{Permitted} and \syn{NotPermitted} decisions. 


The policy translation functions ultimately will return one of the following answers: \\\syn{Permitted}, \syn{NotPermitted} or \syn{Unregulated}. Note that since \ac{ACCPL} was inspired by \ac{drm} systems and their policy languages (\ac{rel}s) we will use ``unregulated'' as synonymous with ``non-applicable'' for the case where a given policy does not apply to a request.


A \syn{Permitted} answer signifies that the access request has been granted. The \syn{NotPermitted} answer is for when the access request is denied. And finally the \syn{Unregulated} answer is for all the times when neither \syn{Permitted} or \syn{NotPermitted} answers are applicable. The \syn{answer} type in the Coq listing~\ref{lst:answercoq} implements the answer concept. We wrap \syn{answer}s in a \syn{result} type and add some context. Intuitively a \syn{result} will tell us whether a subject may perform an action on an asset or not, or else that the request is unregulated. In listing~\ref{lst:answercoq} we also show the definition of the helper function \syn{makeResult} that when given an \syn{answer}, a \syn{subject}, an \syn{act} and an \syn{asset} builds and returns a \syn{result}.


\lstset{language=Coq, frame=single, caption={Decision Procedures: \syn{answer} and \syn{result} types},label={lst:answercoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}

Inductive answer : Set :=
  | Permitted : answer
  | Unregulated : answer
  | NotPermitted : answer.
  
Inductive result : Set :=
  | Result : answer -> subject -> act -> asset -> result.
 
Definition makeResult (ans:answer)(s:subject)(ac:act)(ass:asset) : result := 
 (Result ans s ac ass).
 
\end{lstlisting}
\end{minipage}

\section{Translations}\label{sec:translationfuncs}

Intuitively a query or request asks the following question given an agreement: ``May subject \syn{s} perform an action \syn{ac} to asset \syn{a}?''. We represent a query by its components, namely the subject, action and asset that form the query question: \syn{action_from_query}, \syn{subject_from_query} and \syn{asset_from_query}. While developing the proofs for the correcness of \ac{ACCPL} we realized we needed this query specific information deep in the translation functions to be able to render unambiguous decisions and ultimately make the proofs work. We therefore pass the query components to all the translation functions starting with the \syn{trans_agreement} function (see listing~\ref{lst:transagreement}). 

In the following paragraphs, we will describe each translation function in detail the \syn{trans_agreement} function, however a high-level description of how the main algorithm (encoded in these translation functions) works is now in order. We will show the main algorithm in two separate listings based on whether the policy set in question is inclusive or exclusive. 

The first listing (Algorithm~\ref{inclusivePS}) for inclusive policy sets, shows how a positive answer to a query in the form of a \syn{Permitted} decision is reached. All cases when a decision of \syn{Unregulated} is rendered are explicitly captured and shown. The second listing (Algorithm~\ref{exclusivePS}) for exclusive policy sets, shows how a negative answer to a query in the form of a \syn{NotPermitted} decision is reached. This listing also shows that a positive decision of \syn{Permitted} is reached in exactly the same way as the case for inclusive policy sets. All cases when a decision of \syn{Unregulated} is rendered are explicitly captured and shown.

 
\begin{algorithm}      
\algCaption{Access Decision Pseudocode: Inclusive Policy Sets}       
\label{inclusivePS}   
\begin{algorithmic}        
    \IF{$asset\_from\_query = asset\_from\_agreement$}
      \IF{$subject\_from\_query$ is in $prin\_u$}
        \IF{The $preRequisite$ from the policy set holds}
          \IF{The $preRequisite$ from the policy holds}
            \IF{$action\_from\_query = action\_from\_agreement$}
              \STATE $result$ = $subject\_from\_query$ is $Permitted$ to perform $action\_from\_query$ on $asset\_from\_query$
            \ELSE
              \STATE $result$ = $Unregulated$
            \ENDIF            
          \ELSE
             \STATE $result$ = $Unregulated$
          \ENDIF
        \ELSE
          \STATE $result$ = $Unregulated$
        \ENDIF
      \ELSE
           \STATE $result$ = $Unregulated$
      \ENDIF
    \ELSE
      \STATE $result$ = $Unregulated$
    \ENDIF
\end{algorithmic}
\end{algorithm}


\begin{algorithm}      
\algCaption{Access Decision Pseudocode: Exclusive Policy Sets}            
\label{exclusivePS}   
\begin{algorithmic}        
    \IF{$asset\_from\_query = asset\_from\_agreement$}
      \IF{$subject\_from\_query$ is in $prin\_u$}
        \IF{The $preRequisite$ from the policy set holds}
          \IF{The $preRequisite$ from the policy holds}
            \IF{$action\_from\_query = action\_from\_agreement$}
              \STATE $result$ = $subject\_from\_query$ is $Permitted$ to perform $action\_from\_query$ on $asset\_from\_query$
            \ELSE
              \STATE $result$ = $Unregulated$
            \ENDIF            
          \ELSE
             \STATE $result$ = $Unregulated$
          \ENDIF
        \ELSE
          \STATE $result$ = $Unregulated$
        \ENDIF
      \ELSE
            \IF{$action\_from\_query = action\_from\_agreement$}
              \STATE $result$ = $subject\_from\_query$ is $NotPermitted$ to perform $action\_from\_query$ on $asset\_from\_query$
            \ELSE
              \STATE $result$ = $Unregulated$
            \ENDIF
      \ENDIF
    \ELSE
      \STATE $result$ = $Unregulated$
    \ENDIF
\end{algorithmic}
\end{algorithm}


Pattern matching in the body of the \syn{trans_agreement} function (in listing~\ref{lst:transagreement}), on \syn{ag}, the agreement in question, extracts the components of the agreement. These are \syn{ps}, the policy set, \syn{prin_u}, the agreement's user(s), and \syn{a}, the asset mentioned in the agreement. Notice that formal argument \syn{e} of type \syn{environment} is passed as an argument to many translation functions but will only eventually be used to get the count information from the \syn{getCount} function. As mentioned above, the components of the query or request, namely \syn{action_from_query}, \syn{subject_from_query} and \syn{asset_from_query} make up the other parameters that are passed into the next level translation function, which is the translation for a policy set called \syn{trans_ps} (in listing~\ref{lst:transpsCoq}).

%\section{Policy Combinators And Interpretation Of Results}\label{sec:policycombinators}

The nonempty list of \syn{result}s returned by the agreement translation function will have a result per primitive policy (\syn{primPolicy}) in the agreement. As we will see later when we discuss the proofs, we have proven that results containing a \syn{Permitted} answer and a \syn{NotPermitted} answer are mutually exclusive. Therefore we interpret the existence of a single (or more) \syn{Permitted} result in the nonempty list, as the decision being ``Permitted'' whereas the existence of a single (or more) \syn{NotPermitted} type result is interpreted as ``NotPermitted". We also have a proof that shows that when there exists no \syn{Permitted} or \syn{NotPermitted} results in the returned nonempty list, only \syn{Unregulated} results are possible. In this case we conclude the decision is ``Unregulated''. 

\lstset{language=Coq, frame=single, caption={Translation of Agreement},label={lst:transagreement}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Definition trans_agreement
   (ag:agreement)(e:environment)(action_from_query:act)
   (subject_from_query:subject)(asset_from_query:asset) : nonemptylist result :=

   match ag with
   | Agreement prin_u a ps => 
       (trans_ps e action_from_query subject_from_query asset_from_query ps prin_u a)
   end.
\end{lstlisting}
\end{minipage}

Translation of a policy set (called \syn{trans_ps} in listing~\ref{lst:transpsCoq}), takes as input \syn{e}, the environment, the subject, action and asset coming from a query: \syn{action_from_query}, \syn{subject_from_query} and \syn{asset_from_query}, \syn{ps}, the policy set, \syn{prin_u}, the agreement's user, and \syn{a}, the asset mentioned in the agreement. 

The translation starts with checking that there is a proof for the equality of \syn{asset_from_query} and \syn{a} (the asset from the agreement). This is done by using the decision procedure \syn{eq_nat_dec} (see listing~\ref{lst:eqnatdeccoq}). If so, the translation function recurses on the composing \syn{primPolicySet} and calls the local function \syn{process_single_ps}. Otherwise, the \syn{Unregulated} answer is wrapped along with the subject, action and asset coming from a query: \syn{action_from_query}, \syn{subject_from_query} and \syn{asset_from_query} by calling the \syn{makeResult} helper function. Intuitively we are just explicitly stating that policies are not applicable to queries about assets that are not mentioned in the agreement. 

The \syn{primPolicySet} which was passed to \syn{process_single_ps} was either constructed by a \syn{PIPS} constructor or by a \syn{PEPS} constructor, which distinguish between \syn{primInclusive}--\syn{PolicySet} and \syn{primExclusivePolicySet} types. The translation functions \syn{trans_policy_PIPS} (see listing~\ref{lst:transpipsCoq}) and \syn{trans_policy_PEPS} (see listing~\ref{lst:transpepsCoq}) are called in turn as the case may be.


\lstset{language=Coq, frame=single, caption={Translation of Policy Set},label={lst:transpsCoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Fixpoint trans_ps
  (e:environment)(action_from_query:act)(subject_from_query:subject)(asset_from_query:asset)
  (ps:policySet)
  (prin_u:prin)(a:asset){struct ps} : nonemptylist result :=

let process_single_ps := (fix process_single_ps (pps: primPolicySet):= 
  match pps with 
    | PIPS pips => 
        match pips with 
          | PrimitiveInclusivePolicySet prq p => 
            (trans_policy_PIPS e prq p subject_from_query prin_u a action_from_query)                
        end
    | PEPS peps => 
        match peps with 
          | PrimitiveExclusivePolicySet prq p => 
            (trans_policy_PEPS e prq p subject_from_query prin_u a action_from_query)
        end  
   end) in

if (eq_nat_dec asset_from_query a)
then (* asset_from_query = a *)  
    match ps with
      | PPS pps => process_single_ps pps
    end
else (* asset_from_query <> a *)
       (Single 
          (makeResult 
             Unregulated subject_from_query action_from_query asset_from_query)).
\end{lstlisting}
\end{minipage}


The \syn{trans_policy_PIPS} translation function for a \syn{primInclusivePolicySet} checks whether there is a proof for the subject in question, \syn{x}, being in \syn{prin_u}, by calling the decision procedure \syn{trans_prin_dec} (see listing~\ref{lst:transprindeccoq}). If so there is a check for whether the \syn{preRequisite} from the policy set holds or not by calling the decision procedure \syn{trans_preRequisite_dec} (see listing~\ref{lst:transpreRequisitedeccoq}). If so the translation function \syn{trans_policy_positive} is called. In all other cases \syn{trans_policy_unregulated} (see listing~\ref{lst:transUnregulatedCoq}) is called.

\lstset{language=Coq, frame=single, caption={Translation of Primitive Inclusive Policy Set},
    label={lst:transpipsCoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Definition trans_policy_PIPS
  (e:environment)(prq: preRequisite)(p:policy)(x:subject)
  (prin_u:prin)(a:asset)(action_from_query:act) : nonemptylist result :=
  
    if (trans_prin_dec x prin_u)
    then (* prin *)
      if (trans_preRequisite_dec e x prq (getId p) prin_u)
      then (* prin /\ prq *)
        (trans_policy_positive e x p prin_u a action_from_query)                           
      else (* prin /\ ~prq *)
        (trans_policy_unregulated e x p a action_from_query)
    else (* ~prin *)
      (trans_policy_unregulated e x p a action_from_query).
\end{lstlisting}
\end{minipage}


The \syn{trans_policy_PEPS} translation function for a \syn{primExclusivePolicySet} checks whether there is a proof for the subject in question, \syn{x}, being in \syn{prin_u}, by calling the decision procedure \syn{trans_prin_dec}. If not, the translation function \syn{trans_policy_negative} is called. This is because we are translating a \syn{primExclusivePolicySet} so the policy set is exclusive to the agreement's users implying all subjects, not in the \syn{prin_u} are denied access. In case there is a proof for the subject \syn{x} being in \syn{prin_u}, there is a check for whether the prerequisite from the policy set holds or not (by calling the decision procedure \syn{trans_preRequisite_dec}). If so, the translation function \syn{trans_policy_positive} (see listing~\ref{lst:transPositiveCoq}) is called, else \syn{trans_policy_unregulated} is called.

\lstset{language=Coq, frame=single, caption={Translation of Primitive Exclusive Policy Set},
    label={lst:transpepsCoq}}
\begin{minipage}{\linewidth}
\begin{lstlisting}

Definition trans_policy_PEPS
  (e:environment)(prq: preRequisite)(p:policy)(x:subject)
  (prin_u:prin)(a:asset)(action_from_query:act) : nonemptylist result :=
  
  if (trans_prin_dec x prin_u)
  then (* prin *)
    if (trans_preRequisite_dec e x prq (getId p) prin_u)
    then (* prin /\ prq *)
      (trans_policy_positive e x p prin_u a action_from_query)
    else (* prin /\ ~prq *)
      (trans_policy_unregulated e x p a action_from_query)
  else (* ~prin *)
    (trans_policy_negative e x p a action_from_query).

\end{lstlisting}
\end{minipage}


\newpage

The \syn{trans_policy_positive} translation function (see listing~\ref{lst:transPositiveCoq}) starts by calling the function \syn{trans_pp_list_trans_policy_positive} (see listing~\ref{lst:transListOfPositiveCoq}) on a list of \syn{primPolicy}s.
 
\lstset{language=Coq, frame=single, caption={Translation of Positive Policies},
    label={lst:transPositiveCoq}}
\begin{minipage}{\linewidth}
\begin{lstlisting}
Definition trans_policy_positive
  (e:environment)(x:subject)(p:policy)(prin_u:prin)(a:asset)
  (action_from_query: act) : nonemptylist result :=
  match p with
       | Policy pp_list => trans_pp_list_trans_policy_positive pp_list e x prin_u a action_from_query
  end.
\end{lstlisting}
\end{minipage}

The function \syn{trans_pp_list_trans_policy_positive} (see listing~\ref{lst:transListOfPositiveCoq}) handles the case of a single primitive policy by calling the handler function \syn{process_single_pp_trans_policy_positive} (see listing~\ref{lst:transSinglePositivePolicyCoq}). When there is more than a single primitive policy, the function \syn{trans_pp_list_trans_policy_positive} appends the results of processing a single primitive policy to the results for the rest of the set.

\lstset{language=Coq, frame=single, caption={Translation of Primitive Positive Policies},
    label={lst:transListOfPositiveCoq}}
\begin{lstlisting}
Fixpoint trans_pp_list_trans_policy_positive
  (pp_list:nonemptylist primPolicy)(e:environment)(x:subject)
  (prin_u:prin)(a:asset)(action_from_query: act){struct pp_list}:=
   match pp_list with
     | Single pp1 => process_single_pp_trans_policy_positive pp1 e x prin_u a action_from_query
     | NewList pp pp_list' => app_nonempty
	 (process_single_pp_trans_policy_positive pp e x prin_u a action_from_query) 
	 (trans_pp_list_trans_policy_positive pp_list' e x prin_u a action_from_query)
   end.
\end{lstlisting}


The function \syn{process_single_pp_trans_policy_positive} acting on a single \\ \syn{primPolicy} (see listing~\ref{lst:transSinglePositivePolicyCoq}), first checks whether the prerequisite from the policy holds or not, by calling the decision procedure \syn{trans_preRequisite_dec}. If so the translation function checks that there is a proof for the equality of \syn{action_from_query} and \syn{action} (the \syn{action} from the agreement) by calling the decision procedure \syn{eq_nat_dec}. If so, the translation function finally returns a result of \syn{Permitted}. In all other cases, a result of \syn{Unregulated} is returned. Intuitively we are just explicitly stating that policies are not applicable to queries about actions that are not mentioned in the agreement. 


\lstset{language=Coq, frame=single, caption={Translation of a Primitive Positive Policy},
    label={lst:transSinglePositivePolicyCoq}}
\begin{minipage}{\linewidth}
\begin{lstlisting}
Definition process_single_pp_trans_policy_positive 
   (pp: primPolicy)(e:environment)(x:subject)(prin_u:prin)
   (a:asset)(action_from_query: act)  : nonemptylist result :=
  match pp with
    | PrimitivePolicy prq' policyId action =>
        if (trans_preRequisite_dec e x prq' (Single policyId) prin_u)
        then (* prin /\ prq /\ prq' *)
          if (eq_nat_dec action_from_query action)
          then
            (Single 
              (makeResult Permitted x action_from_query a))
          else
            (Single 
              (makeResult Unregulated x action_from_query a))
        else (* prin /\ prq /\ ~prq' *)
          (Single 
              (makeResult Unregulated x action_from_query a))
  end.
\end{lstlisting}
\end{minipage}


The \syn{trans_policy_negative} translation function (see listing~\ref{lst:transNegativeCoq}) starts by calling the function \syn{trans_pp_list_trans_policy_negative} on a list of \syn{primPolicy}s. Note that \syn{trans_pp_list_trans_policy_negative} is not listed here since it follows the exact pattern as \syn{trans_pp_list_trans_policy_positive} (see listing~\ref{lst:transListOfPositiveCoq}).

\lstset{language=Coq, frame=single, caption={Translation of Negative Policies},
    label={lst:transNegativeCoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Fixpoint trans_policy_negative
  (e:environment)(x:subject)(p:policy)(a:asset)
  (action_from_query: act){struct p} : nonemptylist result :=  
  match p with  
       | Policy pp_list => trans_pp_list_trans_policy_negative pp_list x a action_from_query
  end.
\end{lstlisting}
\end{minipage}

The function \syn{process_single_pp_trans_policy_negative} acting on a single \\ \syn{primPolicy} (see listing~\ref{lst:transSingleNegativePolicyCoq}), first checks that there is a proof for the equality of \syn{action_from_query} and \syn{action} (the \syn{action} from the agreement) by calling the decision procedure \syn{eq_nat_dec}. If so, the translation function returns a result of \syn{NotPermitted}. Otherwise, a result of \syn{Unregulated} is returned. Note that \syn{trans_policy_negative} is called from a context where \syn{trans_prin_dec} is not provable, which means that subject \syn{x}, is not in \syn{prin_u}. Also note that compared to \syn{trans_policy_positive} we don't check for whether \syn{preRequisite} from the policy holds or not, since \syn{trans_policy_negative} is only called for policy sets of type \syn{primExclusivePolicySet}.


\lstset{language=Coq, frame=single, caption={Translation of a Primitive Negative Policy},
    label={lst:transSingleNegativePolicyCoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Definition process_single_pp_trans_policy_negative
   (pp: primPolicy)(x:subject)
   (a:asset)(action_from_query: act)  : nonemptylist result :=
  match pp with
    | PrimitivePolicy prq' policyId action =>
          if (eq_nat_dec action_from_query action)
          then
            (Single 
              (makeResult NotPermitted x action_from_query a))
          else
            (Single 
              (makeResult Unregulated x action_from_query a))
  end.
\end{lstlisting}
\end{minipage}

The \syn{trans_policy_unregulated} translation function (see listing~\ref{lst:transUnregulatedCoq}) starts by calling the function \syn{trans_pp_list_trans_policy_unregulated} on a list of \syn{primPolicy}s. Note that \syn{trans_pp_list_trans_policy_unregulated} is not listed here since it follows the exact pattern as \syn{trans_pp_list_trans_policy_positive} (see listing~\ref{lst:transListOfPositiveCoq}).

\lstset{language=Coq, frame=single, caption={Translation of Unregulated Policies},
    label={lst:transUnregulatedCoq}}
\begin{lstlisting}   
Fixpoint trans_policy_unregulated
  (e:environment)(x:subject)(p:policy)(a:asset)
  (action_from_query: act){struct p} : nonemptylist result :=
  match p with
       | Policy pp_list => trans_pp_list_trans_policy_unregulated pp_list x a action_from_query
  end.
\end{lstlisting}


The function \syn{process_single_pp_trans_policy_unregulated} acting on a single \\ \syn{primPolicy} (see listing~\ref{lst:transSingleUnregulatedPolicyCoq}) simply returns a result of \syn{Unregulated}.



\lstset{language=Coq, frame=single, caption={Translation of an Unregulated Policy},
    label={lst:transSingleUnregulatedPolicyCoq}}
%\begin{minipage}{\linewidth}
\begin{lstlisting}
Definition process_single_pp_trans_policy_unregulated
   (pp: primPolicy)(x:subject)
   (a:asset)(action_from_query: act)  : nonemptylist result :=
  match pp with
    | PrimitivePolicy prq' policyId action =>
        (Single (makeResult Unregulated x action_from_query a))
  end.
\end{lstlisting}




% COQ
Translation of a \syn{prin} (called \syn{trans_prin} in listing~\ref{lst:transprinCoq}) takes as input, a subject \syn{x}, and a principal \syn{p}, and return the proposition ``subject \syn{x} is in principal \syn{p}''. More specifically \syn{trans_prin} proceeds based on whether the principal \syn{p} is a single subject or a list of subjects. If \syn{p} is a single subject \syn{s}, the proposition \syn{x=s} is returned. Otherwise the disjunction of the proposition \syn{x=s} with the proposition ``subject \syn{x} is in principal \syn{rest}'' is returned.

\lstset{language=Coq, frame=single, caption={Translation of Prin},label={lst:transprinCoq}}
\begin{minipage}{\linewidth}
\begin{lstlisting}
Fixpoint trans_prin
  (x:subject)(p: prin): Prop :=

  match p with
    | Single s => (x=s)
    | NewList s rest => ((x=s) \/ trans_prin x rest)
  end.
\end{lstlisting}
\end{minipage}


The translation of a \syn{prerequisite} (called \syn{trans_preRequisite} in listing~\ref{lst:transpreRequisiteCoq}) takes as input an environment \syn{e}, a subject \syn{x}, a \syn{preRequisite} \syn{prq} to translate, a set of policy identifiers \syn{IDs} (identifiers of policies implied by the \syn{prq}), the agreement's user(s) \syn{prin_u}, and proceeds by case analysis on the structure of the \syn{prerequisite}. A \syn{prerequisite} can only have the constructor \syn{PreRequisite} however, which in turn causes the translation function \syn{trans_andPrqs} to be called on a nonempty list of \syn{primPreRequisite}s. Finally for each \syn{primPreRequisite}, the translation function \syn{trans_primPreRequisite} proceeds by case analysis on the structure of the primitive prerequisite. A primitive prerequisite is either \syn{TruePrq}, \syn{Constraint} or \syn{NotCons}.

In listing~\ref{lst:transpreRequisiteCoq} the translation for \syn{TruePrq} is the proposition \syn{True}, the translations for \syn{Constraint} and \syn{NotCons} simply call respective translation functions for corresponding types namely \syn{trans_constraint} (see listing~\ref{lst:transconstraintCoq}) and \syn{trans_notCons} (see listing~\ref{lst:transnotConsCoq}. 


\lstset{language=Coq, frame=single, caption={Translation of Prerequisite},label={lst:transpreRequisiteCoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Definition trans_primPreRequisite  (e:environment)(x:subject)(prq:primPreRequisite)(IDs:nonemptylist policyId)  (prin_u:prin) : Prop :=   match prq with    | TruePrq => True    | Constraint const => trans_constraint e x const IDs prin_u    | NotCons const => trans_notCons e x const IDs prin_u   end.

Fixpoint trans_andPrqs    (e:environment)(x:subject)    (prqs:nonemptylist primPreRequisite)    (IDs:nonemptylist policyId)(prin_u:prin) {struct prqs}: Prop :=      match prqs with     | Single prq => trans_primPreRequisite e x prq IDs prin_u      | NewList prq' rest_prqs =>          (trans_primPreRequisite e x prq' IDs prin_u) /\         (trans_andPrqs e x rest_prqs IDs prin_u)   end.Definition trans_preRequisite  (e:environment)(x:subject)(prq:preRequisite)(IDs:nonemptylist policyId)(prin_u:prin) : Prop :=  match prq with    | PreRequisite prqs => trans_andPrqs e x prqs IDs prin_u  end.
\end{lstlisting}
\end{minipage}

The translation of a \syn{constraint} (called \syn{trans_constraint} in listing~\ref{lst:transconstraintCoq}) takes as input 
an environment \syn{e}, a subject \syn{x}, a \syn{constraint} \syn{const} to translate, a set of policy identifiers \syn{IDs} (identifiers of policies implied by the parent prerequisite), the agreement's user(s) \syn{prin_u} and proceeds by case analysis on the structure of the \syn{constraint}. A \syn{constraint} is either \syn{Principal}, \syn{Count} or a \syn{CountByPrin}. The translation for \syn{Principal} calls the translation function \syn{trans_prin}, for the \syn{prn} that accompanies the \syn{const} constraint. The translation for \syn{Count} and \syn{CountByPrin} both return the proposition which is the translation function \syn{trans_count} (see listing~\ref{lst:transcountCoq}).


\lstset{language=Coq, frame=single, caption={Translation of Constraint},label={lst:transconstraintCoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}

Fixpoint trans_constraint 
  (e:environment)(x:subject)(const:constraint)(IDs:nonemptylist policyId)
  (prin_u:prin){struct const} : Prop := 
  match const with
    | Principal prn => trans_prin x prn
  
    | Count n => trans_count e n IDs prin_u

    | CountByPrin prn n => trans_count e n IDs prn 

  end.
  
\end{lstlisting}
\end{minipage}

The translation of a \syn{NotCons} (called \syn{trans_notCons} in listing~\ref{lst:transnotConsCoq}) takes as input 
an environment \syn{e}, a subject \syn{x}, a \syn{constraint} \syn{const} to translate, a set of policy identifiers \syn{IDs} (identifiers of policies implied by the parent prerequisite), the agreement's user(s) \syn{prin_u} and proceeds to return the negation of the proposition \syn{trans_constraint} (see listing~\ref{lst:transconstraintCoq}).

\lstset{language=Coq, frame=single, caption={Translation of Negation of Constraint},label={lst:transnotConsCoq}}
\begin{lstlisting}

Definition trans_notCons
  (e:environment)(x:subject)(const:constraint)(IDs:nonemptylist policyId)(prin_u:prin) : Prop :=
  ~ (trans_constraint e x const IDs prin_u).
\end{lstlisting}


The translation of a \syn{Count} or a \syn{CountByPrin} (called \syn{trans_count} in listing~\ref{lst:transcountCoq}) takes as input an environment \syn{e}, \syn{n} the total number of times the subjects mentioned in \syn{prin_u} may invoke the 
the policies identified by \syn{IDs}.
A local variable \syn{running_total} has the current count of the number of times subjects in \syn{prin_u} have invoked the policies. Finally the proposition \syn{running_total < n} is returned as the translation for a \syn{Count} or a \syn{CountByPrin}. Functions \syn{process_two_lists} and \syn{trans_count_aux} are defined in listings~\ref{lst:transcountprocesstwolistsCoq} and~\ref{lst:transcountauxCoq} respectively.

Note that the only difference between translations for a \syn{Count} and a \syn{CountByPrin} is the additional \syn{prn} parameter for \syn{CountByPrin} which allows for getting counts for subjects not necessarily the same as \syn{prin_u}, the agreement's user(s). We therefore omit the definition for \syn{CountByPrin}.


\lstset{language=Coq, frame=single, caption={Translation of Count},label={lst:transcountCoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Fixpoint trans_count
  (e:environment)(n:nat)(IDs:nonemptylist policyId)
  (prin_u:prin) : Prop :=
  let ids_and_subjects := process_two_lists IDs prin_u in
  let running_total := trans_count_aux e ids_and_subjects in
  running_total < n.
\end{lstlisting}
\end{minipage}


To implement the translation for a \syn{Count} or a \syn{CountByPrin} we start by calling an auxiliary function \syn{process_two_lists} (see listing~\ref{lst:transcountprocesstwolistsCoq}) that effectively returns a new list composed of pairs of members of the first list and the second list (the cross-product of the two input lists). In the case of \syn{trans_count}, the call is ``\syn{process_two_lists} \syn{IDs} \syn{prin_u}'' which returns a list of pairs of \syn{policyId} and \syn{subject} namely \syn{ids_and_subjects}. \syn{ids_and_subjects} is then passed to a locally defined function called \syn{trans_count_aux}.

\lstset{language=Coq, frame=single, caption={Count Helper: Cross-Product of Two Lists, \syn{process_two_lists}},label={lst:transcountprocesstwolistsCoq}}
%\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}

Section Process_Lists.

Variable X : Set.
Variable Y : Set.

Fixpoint process_two_lists (l1 : nonemptylist X) (l2 : nonemptylist Y) :  nonemptylist (Twos X Y) :=

let process_element_list := (fix process_element_list (e1 : X) (l2 : nonemptylist Y) :	nonemptylist (Twos X Y) :=
  match l2 with
    | Single s => Single (mkTwos e1 s)
    | NewList s rest => app_nonempty (Single (mkTwos e1 s)) (process_element_list e1 rest)
  end) in

  match l1 with
    | Single s => process_element_list s l2
    | NewList s rest => app_nonempty (process_element_list s l2) (process_two_lists rest l2)
  end.

End Process_Lists.

\end{lstlisting}
%\end{minipage}


The function \syn{trans_count_aux} (see listing~\ref{lst:transcountauxCoq}) returns the current count for a single pair of \syn{policyId} and \syn{subject} (the call to \syn{getCount} which looks up the environment \syn{e} and returns the current count per each \syn{subject} and \syn{policyId}) and for a list of pairs of \syn{policyId} and \syn{subject}s, the addition of \syn{get_count} (for the first pair) and \syn{trans_count_aux}s (for the rest of the pairs) is returned. 

\lstset{language=Coq, frame=single, caption={Count Helper: \syn{trans_count_aux}},label={lst:transcountauxCoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}

Fixpoint trans_count_aux (e:environment)(ids_and_subjects : nonemptylist (Twos policyId subject)) : nat :=
  match ids_and_subjects with
	| Single pair1 => getCount e (right pair1) (left pair1)
	| NewList pair1 rest_pairs =>
	    (getCount e (right pair1)(left pair1)) +
	    (trans_count_aux e rest_pairs)
  end.
\end{lstlisting}
\end{minipage}


At this point we have covered the semantics of \ac{ACCPL} in terms of translation functions starting with \syn{trans_agreement}. In the following listings we will show an example agreement from~\cite{pucella2006} expressed as abstract syntax and as \ac{ACCPL}. We will also show how the fully built agreement looks like as \ac{ACCPL} constructs and we will show how a number of queries can be asked and what the results would be and whether the results are as expected.

The statement in listing~\ref{lst:pucellatwofourexampleAST} expresses that ``the asset TheReport may be printed and displayed by Alice and Bob only and with the restriction that Alice and Bob together may print and display the asset five times".

\lstset{language=Pucella2006}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}[frame=single, caption={Agreement of Example 2.4}, label={lst:pucellatwofourexampleAST}, mathescape]
agreement
 for Alice and Bob and Charlie
 about The Report 
 with and[{Alice, Bob}, {Alice, Bob}<count[5]>] -> and[True =>$_{id1}$ print, True =>$_{id2}$ display].
\end{lstlisting}
\end{minipage} 

The policy statement in~\ref{lst:pucellatwofourexampleAST} is expressed in \ac{ACCPL} using Coq constructs, in listing~\ref{lst:pucellatwofourexamplecoq}.

\lstset{language=Coq, frame=single, caption={Expressing Agreement of Example 2.4 in ACCPL}, label={lst:pucellatwofourexamplecoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Definition ps_24_p1:primPolicy :=   (PrimitivePolicy (makePreRequisite (TruePrq)) id1 Print).Definition ps_24_p2:primPolicy :=   (PrimitivePolicy (makePreRequisite (TruePrq)) id2 Display).Definition ps_24_p:policy :=   (Policy (NewList ps_24_p1 (Single ps_24_p2))).Definition ps_24_prq1:primPreRequisite :=   (Constraint (Principal (NewList Alice (Single Bob)))).Definition ps_24_prq2:primPreRequisite :=   (Constraint (CountByPrin (NewList Alice (Single Bob)) 1)). Definition ps_24_prq:preRequisite :=   (PreRequisite (NewList ps_24_prq1 (Single ps_24_prq2))).Definition ps_24:primPolicySet :=  PIPS (PrimitiveInclusivePolicySet    ps_24_prq ps_24_p).Definition A24 := Agreement (NewList Alice (Single Bob)) TheReport (PPS ps_24).\end{lstlisting}
\end{minipage} 

The policy statement in listing~\ref{lst:pucellatwofourexampleAST} as an \ac{ACCPL} construct is shown, in listing~\ref{lst:pucellatwofourexamplecoq2}.

\lstset{language=Coq, frame=single, caption={Fully Built Agreement of Example 2.4 in ACCPL}, label={lst:pucellatwofourexamplecoq2}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Agreement (Alice, [Bob]) TheReport         (PPS            (PIPS               (PrimitiveInclusivePolicySet                  (PreRequisite                     (Constraint (Principal (Alice, [Bob])),                      [Constraint (CountByPrin (Alice, [Bob]) 1)])                  (Policy                     (PrimitivePolicy (PreRequisite [TruePrq]) id1 Print,                      [PrimitivePolicy (PreRequisite [TruePrq]) id2 Display])))))

\end{lstlisting}
\end{minipage} 

The default environment for the example agreement is shown in listing~\ref{lst:pucellatwofourexamplecoq3}. We set all the counts to zero initially.

\lstset{language=Coq, frame=single, caption={The Default Environment for Example 2.4 in ACCPL}, label={lst:pucellatwofourexamplecoq3}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Definition e_24 : environment := (ConsEnv (make_count_equality Bob id1 0)   (ConsEnv (make_count_equality Bob id2 0)     (ConsEnv (make_count_equality Alice id1 0)       (SingleEnv (make_count_equality Alice id2 0))))).\end{lstlisting}
\end{minipage} 

The query in listing~\ref{lst:pucellatwofourexamplecoq4}, asks whether Alice may print the asset TheReport. We expect the action to be allowed based on the first primitive policy. The second primitive policy mentions a different action (e.g. Display) so we expect the request is unregulated. 

\lstset{language=Coq, frame=single, caption={Query: May Alice Print The Report for Example 2.4 in ACCPL}, label={lst:pucellatwofourexamplecoq4}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Eval compute in (trans_agreement e_24 A24 Print Alice TheReport). = 
   Result Permitted Alice Print TheReport, [Result Unregulated Alice Print TheReport]
\end{lstlisting}
\end{minipage} 

The query in listing~\ref{lst:pucellatwofourexamplecoq5}, asks whether Charlie may print the asset TheReport. We expect the action to be unregulated because Charlie fails to meet the prerequisites specified for the policy set. 

\lstset{language=Coq, frame=single, caption={Query: May Charlie Print The Report for Example 2.4 in ACCPL}, label={lst:pucellatwofourexamplecoq5}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Eval compute in (trans_agreement e_24 A24 Print Charlie TheReport). = 
   Result Unregulated Charlie Print TheReport, [Result Unregulated Charlie Print TheReport]
\end{lstlisting}
\end{minipage} 

The query in listing~\ref{lst:pucellatwofourexamplecoq6}, asks whether Alice may display the asset TheReport. We expect the action to be allowed based on the second primitive policy. The first primitive policy mentions a different action (e.g. Print) so we expect the request is unregulated. 

\lstset{language=Coq, frame=single, caption={Query: May Alice Display The Report for Example 2.4 in ACCPL}, label={lst:pucellatwofourexamplecoq6}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Eval compute in (trans_agreement e_24 A24 Display Alice TheReport). = 
   Result Unregulated Alice Display TheReport, [Result Permitted Alice Display TheReport]
\end{lstlisting}
\end{minipage} 






\section{Decision Procedures}\label{sec:decprocs}

In the following we will list only the declaration of each decision procedure and the accompanying functions. The individual decision procedures were used as a building block to make the final correcness proofs for \ac{ACCPL} possible. We will refer to some of these listings later when we discuss the translations and/or proofs using the decision procedures. Please refer to the source code where the usage of a decision procedure in not mentioned in the following.

The decision procedure \syn{eq_nat_dec} takes two natural numbers, and declares that either there is a proof for their equality or there exists a proof for their inequality (see listing~\ref{lst:eqnatdeccoq}).

\lstset{language=Coq, frame=single, caption={Decision Procedures: \syn{eq_nat_dec}~\cite{Coq:manual}},label={lst:eqnatdeccoq}}
\begin{lstlisting}
Theorem eq_nat_dec : forall n m, {n = m} + {n <> m}.
\end{lstlisting}

The decision procedure \syn{subject_in_prin_dec} (see listing~\ref{lst:issubjectinprincoq}) declares that either there is a proof for the proposition \syn{is_subject_in_prin} (see listing~\ref{lst:issubjectinprincoq}) or there exists a proof for its negation. 

\lstset{language=Coq, frame=single, caption={Decision Procedures: \syn{subject_in_prin_dec}},label={lst:issubjectinprincoq}}
\begin{lstlisting}
Theorem subject_in_prin_dec :
    forall (a:subject) (l:prin), {is_subject_in_prin a l} + {~ is_subject_in_prin a l}.

Fixpoint is_subject_in_prin (s:subject)(p:prin): Prop :=
  match p with
  | Single s'  => s=s'
  | NewList s' rest => s=s' \/ (is_subject_in_prin s rest)
  end.
\end{lstlisting}

The decision procedure \syn{trans_prin_dec} declares that either there is a proof for the proposition \syn{trans_prin} or there exists a proof for its negation (see listing~\ref{lst:transprindeccoq}). The translation function \syn{trans_prin} is the proposition ``subject x is in prin'' (see listing~\ref{lst:transprinCoq}).

\lstset{language=Coq, frame=single, caption={Decision Procedures: \syn{trans_prin_dec}},label={lst:transprindeccoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem trans_prin_dec :
   forall (x:subject)(p: prin), {trans_prin x p} + {~trans_prin x p}.
\end{lstlisting}
\end{minipage}

The decision procedure \syn{trans_count_dec} declares that either there is a proof for the proposition \syn{trans_count} or there exists a proof for its negation (see listing~\ref{lst:transcountdeccoq}). Recall the translation function \syn{trans_count} is mostly the proposition \syn{running_total < n} with some local context (see listing~\ref{lst:transcountCoq}).

\lstset{language=Coq, frame=single, caption={Decision Procedures: \syn{trans_count_dec}},label={lst:transcountdeccoq}}
\begin{lstlisting}
Theorem trans_count_dec: 
  forall (e:environment)(n:nat)(IDs:nonemptylist policyId)(prin_u:prin), 
    {trans_count e n IDs prin_u} + {~ trans_count e n IDs prin_u}.
\end{lstlisting}

The decision procedure \syn{trans_constraint_dec} declares that either there is a proof for the proposition \syn{trans_constraint} or there exists a proof for its negation (see listing~\ref{lst:transconstraintdeccoq}). The translation function \syn{trans_constraint} is listed in listing~\ref{lst:transconstraintCoq}. 


\lstset{language=Coq, frame=single, caption={Decision Procedures: \syn{trans_constraint_dec}},label={lst:transconstraintdeccoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem trans_constraint_dec :
    forall (e:environment)(x:subject)(const:constraint)(IDs:nonemptylist policyId)(prin_u:prin),
       {trans_constraint e x const IDs prin_u} + {~trans_constraint e x const IDs prin_u}.
\end{lstlisting}
\end{minipage}

The decision procedure \syn{trans_notCons_dec} declares that either there is a proof for the proposition \syn{trans_notCons} or there exists a proof for its negation (see listing~\ref{lst:transnotConsdeccoq}). The translation function \syn{trans_notCons} is listed in listing~\ref{lst:transnotConsCoq}. The proof for \syn{trans_notCons_dec} not shown here uses two helper theorems. One is another decision procedure, \\ \syn{trans_negation_constraint_dec} which declares that either there exists a proof for the negation of \syn{trans_constraint} or there is a proof for the negation of the negation of \syn{trans_constraint}. The other helper theorem is \syn{double_neg_constraint} which basically declares that \syn{trans_constraint} implies its own double negation. The helpers are listed in~\ref{lst:transnegationconstraintdeccoq}.

\lstset{language=Coq, frame=single, caption={Decision Procedures: \syn{trans_negation_constraint_dec}},label={lst:transnegationconstraintdeccoq}}
\begin{lstlisting}
Theorem double_neg_constraint:
    forall (e:environment)(x:subject)(const:constraint)(IDs:nonemptylist policyId)(prin_u:prin),
       (trans_constraint e x const IDs prin_u) -> ~~(trans_constraint e x const IDs prin_u).
  
Theorem trans_negation_constraint_dec :
    forall (e:environment)(x:subject)(const:constraint)(IDs:nonemptylist policyId)(prin_u:prin),
       {~trans_constraint e x const IDs prin_u} + {~~trans_constraint e x const IDs prin_u}.
       
\end{lstlisting}

\lstset{language=Coq, frame=single, caption={Decision Procedures: \syn{trans_notCons_dec}},label={lst:transnotConsdeccoq}}
\begin{minipage}[c]{0.95\textwidth}
\begin{lstlisting}
Theorem trans_notCons_dec :
    forall (e:environment)(x:subject)(const:constraint)(IDs:nonemptylist policyId)(prin_u:prin),
       {trans_notCons e x const IDs prin_u} + {~ trans_notCons e x const IDs prin_u}.

\end{lstlisting}
\end{minipage}

The decision procedure \syn{trans_preRequisite_dec} declares that either there is a proof for the proposition \syn{trans_preRequisite} or there exists a proof for its negation (see listing~\ref{lst:transpreRequisitedeccoq}). The translation function \syn{trans_preRequisite} is listed in listing~\ref{lst:transpreRequisiteCoq}). 


\lstset{language=Coq, frame=single, caption={Decision Procedures: \syn{trans_preRequisite_dec}},label={lst:transpreRequisitedeccoq}}
\begin{lstlisting}
Theorem trans_preRequisite_dec :
    forall (e:environment)(x:subject)(prq:preRequisite)(IDs:nonemptylist policyId)(prin_u:prin),
       {trans_preRequisite e x prq IDs prin_u} + {~ trans_preRequisite e x prq IDs prin_u}.
\end{lstlisting}


%\section{Queries}
%
%Ultimately policy statements describing an agreement will be used to enforce those agreements. To enforce policy agreements, access queries or requests are asked from the policy engine and access is granted or denied based on the answer.
%
%In this chapter we will review our encoding of queries in Coq and Coq representations of other definitions used to prove our decidability results.
%
%Queries are tuples of the form \syn{(agreement, s, action, a, e)}. The tuple corresponds to the question of determining whether an agreement implies that a subject \syn{s} may perform action \syn{action} on an asset \syn{a} given the environment \syn{e}. The Coq representation is listed in listing~\ref{lst:querycoq}. 
%
%\lstset{language=Coq, frame=single, caption={Queries},label={lst:querycoq}}
%\begin{minipage}[c]{0.95\textwidth}
%\begin{lstlisting}
%
%Inductive single_query : Set := 
%   | SingletonQuery : agreement -> subject -> act -> asset -> environment -> single_query.
%   
%\end{lstlisting}
%\end{minipage}
%
%\subsection{Answering Queries}\label{subsec:answerqueriesodrl}
%
%Access control models typically use a two-valued decision set to indicate whether an access request is granted or denied. However many access-control models have extended this two valued set with two more values: non applicable policies to certain queries and an error case accounting for all possible error conditions when evaluating an access request~\cite{DBLP:conf/sacmat/MorissetZ14}. Answering a query could therefore lead to one of four values: error(listing~\ref{lst:errordecision}), permitted(listing~\ref{lst:permitdecision}), denied(listing~\ref{lst:denydecision}) and ``not applicable'' (listing~\ref{lst:notapplicabledecision}) as defined in~\cite{Tschantz}. Note that \syn{e} denotes 'an environment being consistent in the following listings. As we will see later in chapter~\ref{chap:results} (listing~\ref{lst:permandnotpermmutualexclusive}) \ac{ACCPL} ends up using a three valued decision set with only the permit, deny and non applicable cases. 
%
%\lstset{mathescape, language=AST} 
%\begin{lstlisting}[frame=single, caption={Answerable Queries: Error},label={lst:errordecision}]
%
%$([\![ agreement]\!] \land e) \implies Permitted(s, act, a)$ and $([\![ agreement]\!] \land e) \implies \lnot Permitted(s, act, a)$
%
%\end{lstlisting}
%
%\lstset{mathescape, language=AST} 
%\begin{lstlisting}[frame=single, caption={Answerable Queries: Permit},label={lst:permitdecision}]
%
%$([\![ agreement]\!]) \land e) \implies Permitted(s, act, a)$ and $([\![ agreement]\!] \land e) \notimplies \lnot Permitted(s, act, a)$
%
%\end{lstlisting}
%
%\lstset{mathescape, language=AST} 
%\begin{lstlisting}[frame=single, caption={Answerable Queries: Deny},label={lst:denydecision}]
%
%$([\![ agreement]\!] \land e) \notimplies Permitted(s, act, a)$ and $([\![ agreement]\!] \land e) \implies \lnot Permitted(s, act, a)$
%
%\end{lstlisting}
%
%\lstset{mathescape, language=AST} 
%\begin{lstlisting}[frame=single, caption={Answerable Queries: Not Applicable},label={lst:notapplicabledecision}]
%
%$([\![ agreement]\!] \land e) \notimplies Permitted(s, act, a)$ and $([\![ agreement]\!] \land e) \notimplies \lnot Permitted(s, act, a)$
%
%\end{lstlisting}





















