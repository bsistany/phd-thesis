% A B S T R A C T
% ---------------

\begin{center}\textbf{Abstract}\end{center}

We present the design and implementation of a \ac{ACCPL} that can be used to express access-control rules and policies. Although full-blown access-control policy languages such as eXtensible Access Control Markup Language \\(XACML)~\cite{xacml} already exist, because access rules in such languages are often expressed in a declarative manner using fragments of a natural language like English, it isn't always clear what the intended behaviour of the system encoded in these access rules should be. To remedy this ambiguity, formal specification of how an access-control mechanism should behave, is typically given in some sort of logic, often a subset of first order logic. To show that an access-control system actually behaves correctly with respect to its specification, proofs are needed, however the proofs that are often presented in the literature are hard or impossible to formally verify. The verification difficulty is partly due to the fact that the language used to do the proofs while mathematical in nature, utilizes intuitive justifications to derive the proofs. Intuitive language in proofs means that the proofs could be incomplete and/or contain subtle errors.

\ac{ACCPL} is minimal by design. Minimality refers to the size of the language; the syntax, auxiliary definitions and the semantics of \ac{ACCPL} only take a few pages to describe. This compactness allows us to concentrate on the main goal of this thesis which is the ability to reason about the policies written in \ac{ACCPL} with respect to specific questions. By making the language compact, we have stayed away from completeness and expressive power in several directions. For example, \ac{ACCPL} uses only a single policy combinator, the conjunction policy combinator. The design of \ac{ACCPL} is therefore a trade-off between ease of formal proof of correctness and expressive power.

We also consider \ac{ACCPL} a core policy access-control language since we have retained the core features of many access-control policy languages, For instance \ac{ACCPL} employs a single condition of type ``requirement'' where other languages may have very expressive and rich sets of requirements. 

In this thesis, we describe the design of ACCPL and its implementation in Coq.  Using Coq to implement ACCPL as it was being defined was an important factor in its design, allowing us to address the trade-off between expressive power and ease of formal proof of correctness. We argue that \ac{ACCPL} is significantly more amenable to analysis and reasoning than other access-control policy languages, while still retaining sufficient expressive power, and we describe how the design choices that were made contributed to this ease of reasoning. 

The semantics of \ac{ACCPL} are specified by translation from policy statements together with an access request and an environment containing all relevant facts, to decisions. We present decidability results for the decision problem that asks whether a request to access a resource may be granted or denied, given a policy. The translation functions also cover the case where a given policy does not apply to a request in which case a decision of ``request is unregulated'' is rendered. We show that the translation algorithm terminates on all input policies with a decision of granted, denied or unregulated. Furthermore, we show that the translation algorithm meets its specification and computes the correct decision, with respect to its specification, given a policy. 

\cleardoublepage
%\newpage

