\documentclass{beamer}
\usepackage{coqdoc}
\usepackage{color}
\usepackage{listings,lstautogobble}
\usepackage{etoolbox}
\usepackage{fixltx2e}
\usepackage{syntax}
\usepackage{lstcoq}
\usepackage{url}
\usepackage{acro}

\definecolor{maroon}{rgb}{0.5,0,0}
\definecolor{darkgreen}{rgb}{0,0.5,0}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[frenchb]{babel}
\usepackage{setspace}
\usepackage{color}
\usepackage{listings}

\lstdefinelanguage{AST}
{
  basicstyle=\ttfamily,
  breaklines=true,
  morekeywords={
    agreement, prin, asset, subject, policySet, policy, act, policyId, preRequisite 
  }
  tabsize=1,
}


\usetheme{Copenhagen}
\title{YACPL: Yet Another Core Policy Language}
\author{Bahman Sistany}
\date{\today}
\setbeamertemplate{frametitle}[default][center]
\newcommand\FontForteen{\fontsize{14}\selectfont}
\newcommand\FontTen{\fontsize{10}\selectfont}
\begin{document}
%% title frame
\begin{frame}
\titlepage
\end{frame}

%% normal frame 1
\begin{frame}{DRM}
\begin{itemize}
   \item Digital Rights Management (DRM):
   \begin{itemize}
      \item Digital management of rights associated with the access or usage of digital assets.
   \end{itemize}

   \item DRM is Concerned with Four Areas:
     \begin{itemize}
	\item Defining Rights
	\item Distributing/Acquiring Rights
	\item Enforcing Rights
	\item Tracking Usage.
     \end{itemize}
\end{itemize}
\end{frame}
%% slide 3
\begin{frame}[fragile]{Defining Rights}
%% \tiny \small \normalsize \large \Large \LARGE \huge \Huge
\LARGE
\begin{itemize}
\item Rights Expressions
   \begin{itemize}
   \item Anyone who pays 5\$ may watch the movie ``Terminator''
   \end{itemize}
\item Rights are Expressed Using Rights Expression Languages (REL)
\item Examples are ODRL and XrML
\end{itemize}
\end{frame}
%% slide 4
\begin{frame}[fragile]{RELs}
\LARGE
\begin{itemize}
\item Both XrML and ODRL are XML based and declarative
\item Adoption and Usage is Still Limited
   \begin{itemize}
   \item Due to Complexity 
   \item And the fact that they try to cover Enforcement and Tracking Aspects of DRM
   \item Instead of focusing on Expressing Rights
   \end{itemize}
\end{itemize}
\end{frame}
%% slide 5
\begin{frame}[fragile]{ODRL and Rights Expressions: Syntax}
\lstset{language=XML}
\begin{lstlisting}[caption={Syntax of Policies in XML}]
<agreement> 
<asset> Terminator </asset> 
	<permission>   <watch> </watch>  
		<requirement>   
			<payment> 5.00$ </payment>
		</requirement> 
	</permission> 
<party> Anyone </party>
</agreement>
\end{lstlisting}
\end{frame}
%% slide 6
\begin{frame}[fragile]{ODRL and Rights Expressions: Semantics}
\Large
\begin{itemize}
\item Formal Methods ensure a System behaves wrt the Specification of Desired Property
\item The Specification of Desired Behavior is called the Semantics of the System
\item Precise and Formal Semantics are needed to make Reasoning about the system Properties possible
\item Current RELs use Natural Language (e.g. English) for Semantics
   \begin{itemize}
    \item Which doesn`t help with Analysis and Reasoning because policies are Ambiguous and Open to Interpretation
    \end{itemize}    
\end{itemize}
\end{frame}
%% slide 7
\begin{frame}[fragile]{ODRL and Rights Expressions: Formal Semantics}
\LARGE
\begin{itemize}
\item Several approaches to Formalizing the Semantics of RELs and ODRL:
   \begin{itemize}
      \item Logic Based
      \item Finite Automata
      \item Operational Semantics and Interpreter based
      \item Web Ontology
    \end{itemize}
\item Not surprisingly we are interested in the Logic Based approach
\end{itemize}
\end{frame}
%% slide 8
\begin{frame}[fragile]{A Formal Foundation for ODRL: \newline Riccardo Pucella and Vicky Weissman}
\Large
\begin{itemize}
\item Semantics of ODRL is described in English
   \begin{itemize}
      \item Example: Alice owns two Printers but wants to allow Bob to Use the Printers as well. 
      \item Alice writes the agreement as ``Bob may use printer One or Two''
      \item Alice chooses Printer One Since Agreement doesn`t say she CANNOT
      \item Bob also chooses Printer One Since Agreement Implies he Could
      \item Alice and Bob clearly understand the meaning of the Agreement differently
      \item Such Agreements are Possible to write in ODRL and the English specifications of ODRL does NOT address the ambiguity
    \end{itemize}

\item Weissman and Pucella proposed a Formal Semantics for a representative subset of ODRL
\item Based on Many-Sorted-Logic
\item They used their Semantics to Determine Precisely when an Agreement Implies a Permission
\item They Also Showed that Answering Such Questions is Decidable but NP-Hard.
\item Finally They Identify A Problematic Construct in ORDL and Show that without it the Decision Problem can be Answered Efficiently

\end{itemize}
\end{frame}
%% slide 9
\begin{frame}[fragile]{Paper-Proofs}
\begin{itemize}
\item Pucella et al. use their defined semantics to Declare and Prove some Important Theorems about their ODRL subset
\begin{itemize}
\item Their Focus being on stating and proving algorithm Complexity results
\end{itemize}
\item However As with many Paper-Proofs, the Language used to do the proofs while Mathematical in nature, uses many Intuitive Justifications to show the proofs
\item As a Result the Proofs are Hard to Verify and to ``derive'' (or reproduce)
\begin{itemize}
\item Furthermore the proofs CANNOT be used Directly to render a Decision on a sample Policy (allow or deny access to an asset)
\item Although one can Carefully construct programs based on these paper-proofs, there is no way to Certify these programs even assuming the Original Proofs were indeed Correct
\end{itemize}
\item We Need Machine-Checked Proofs
\end{itemize}
\end{frame}
%% slide 10
\begin{frame}[fragile]{Coq: Why Coq?}
\small
\begin{itemize}
\item Coq is known first and foremost as a proof-assistant.
\item Coq uses a much more expressive version of typed lambda calculus called CIC (Calculus of Inductive Constructions) as its logical foundation
    \begin{itemize}
       \item Where proofs and programs can both be represented.
       \item CIC adds polymorphism (terms depending on types), type operators (types depending on types) and dependent types (types depending on terms).
       \item Assertions or propositions are statements about values in Coq such as `3<8` or `8<3` that may be true, false or even be only conjectures. 
       \item Only those propositions are considered to be true, which are provable constructively, i.e., by providing an explicit proof term, that inhabits them.
       \item Verification of complex proofs is possible because one can verify the intermediate proofs or sub-goals in steps, each step being derived from the previous by following precise derivation rules. 
       \item The Coq proof engine solves successive goals by using tactics. Coq tactics are commands to manipulate the local context and to decompose a goal into simpler goals or sub-goals
   \end{itemize}
\end{itemize}
\end{frame}
%% slide 10.5
\begin{frame}[fragile]{Coq: Why Coq? The Real Reasons :-)}
\Large
\begin{itemize}
\item Familiarity with Coq 
\item A very active community and the Coq mailing lists
\item A wealth of information on Coq such as tutorials and several books, meant that:
   \begin{itemize}
       \item Coq was quite suitable or formal program verification
       \item And in particular for developing Certified Policies and Policy Languages
   \end{itemize}
\end{itemize}
\end{frame}
%% slide 11
\begin{frame}[fragile]{ODRL0}
\begin{itemize}
\item Started with encoding and representing Pucella et al`s ODRL subset Including their Semantics in Coq
\item Reduced and modified by Allowing only one kind of Environmental Fact (e.g. Counts)
   \begin{itemize}
      \item The other two Facts are similar to Counts and don`t add anything significant or interesting in terms of provability 
   \end{itemize}
\item Made other changes in the Grammar to accommodate Coq`s requirement for Clearly Terminating Recursion
    \begin{itemize}
        \item ForEachMember is a direct PreRequisite
        \item As Opposed to being a Constraint (which is a PreRequisite)
    \end{itemize}
\item This is what we had called ODRL0 at Proposal time
\end{itemize}
\end{frame}
%% slide 12
\begin{frame}[fragile]{Queries}
\begin{itemize}
\item Policy Statements describing an Agreement are used to Enforce those Agreements 
\item To Enforce Policy, Access Queries are asked from the Policy Engine
    \begin{itemize}
       \item Access is Granted or Denied based on the Answer.
       \item A Query encodes the Question of Whether a set of Agreements Imply that a subject may Perform an Action on an Asset given an Environment.
     \end{itemize}
\item Answering Queries in Pucella et al`s ODRL subset are Decidable
\item We set out to develop a proof in Coq on whether Answering Queries in ODRL0 was also Decidable
\item The idea was to use Pucella et al`s decidablity Algorithm to Answer Queries
\end{itemize}
\end{frame}
%% slide 13
\begin{frame}[fragile]{Closed World Assumption: CWA}
\begin{itemize}
\item We certainly expected we had to modify ODRL0 as presented at the Proposal -- to arrive at Decidability results in Coq
\item However the modifications were thought to be minor
\item ODRL0 even though a subset of Pucella et al`s ODRL in minor ways, maintained the central semantic definitions
\item Including ``Closed World Assumptions'' where the semantics only specify explicitly Permitted and ~Permitted answers
\item Therefore the semantics as stated by Pucella et al. are not Complete
\item Major modifications had to be done to repair the Semantics of ODRL0 and consequently to Pucella et al`s ODRL to make the proofs possible
\item We will therefore refer to the resulting language as ``(Yet Another) Core Policy Language''  --YACPL and not ODRL0 
\end{itemize}
\end{frame}
%% slide 14
\begin{frame}[fragile]{ACPL: A Core Policy Language}
\small
\begin{itemize}
\item DRM can be seen as a Domain Specific Access-Control Mechanism
    \begin{itemize}
       \item ODRL vs XACML
   \end{itemize}
\item We Can Attempt to use ACPL as the Basis for a Core Policy Language suitable for both DRM and general-purpose Access-Control
\item Lesson Learned: Design of Certifiable Policy languages cannot be done in isolation
\item Certifiability/Provability of the language derives the design one way while expressiveness requirements of the language usually drive it in an opposite direction
\item Certifiability/Provability cannot be a post-design activity as the changes it will impose are often fundamental changes
\end{itemize}
\end{frame}
% slide 15
\begin{frame}[fragile]{ODRL0 Syntax}
\lstset{language=Coq}
\begin{lstlisting}
Inductive agreement : Set :=
  | Agreement : prin -> asset -> policySet -> agreement.

Inductive policySet : Set :=
  | PrimitivePolicySet : preRequisite -> policy -> policySet 
  | PrimitiveExclusivePolicySet : preRequisite -> policy  -> policySet 
  | AndPolicySet : nonemptylist policySet -> policySet.

Inductive policy : Set :=
  | PrimitivePolicy : preRequisite -> policyId -> act -> policy 
  | AndPolicy : nonemptylist policy -> policy.

\end{lstlisting}
\end{frame}
% slide 16
\begin{frame}[fragile]{ODRL0 Semantics: trans\_ps}
\lstset{language=Coq}
\begin{lstlisting}

    match ps with
    | PrimitivePolicySet prq p => 
          forall x, (((trans_prin x prin_u) /\ 
                  (trans_preRequisite e x prq (getId p) prin_u)) -> 
                              (trans_policy_positive e x p prin_u a))  
    | PrimitiveExclusivePolicySet prq p => 
          forall x, ((((trans_prin x prin_u) /\ 
                  (trans_preRequisite e x prq (getId p) prin_u)) -> 
                           (trans_policy_positive e x p prin_u a)) /\ ((not (trans_prin x prin_u)) -> 
                              (trans_policy_negative e x p a)))                  
    | AndPolicySet ps_list => 
    end.
\end{lstlisting}
\end{frame}
% slide 17
\begin{frame}[fragile]{ODRL0 Semantics: trans\_policy\_positive}
\lstset{language=Coq}
\begin{lstlisting}

  match p with
    | PrimitivePolicy prq policyId action => ((trans_preRequisite e x prq (Single policyId) prin_u) ->
                                              (Permitted x action a))
    | AndPolicy p_list => 
  end.
\end{lstlisting}
\end{frame}

% slide 18
\begin{frame}[fragile]{ODRL0 Semantics: trans\_policy\_negative}
\lstset{language=Coq}
\begin{lstlisting}
match p with
    | PrimitivePolicy prq policyId action => not (Permitted x action a)
    | AndPolicy p_list => 
  end.
\end{lstlisting}
\end{frame}
% slide 19
\begin{frame}[fragile]{YACPL Syntax (1)}
\lstset{language=Coq}
\begin{lstlisting}
Inductive agreement : Set :=
  | Agreement : prin -> asset -> policySet -> agreement.

Inductive primPolicy : Set :=
  | PrimitivePolicy : preRequisite -> policyId -> act -> primPolicy.

Inductive policy : Set :=
  | Policy : nonemptylist primPolicy -> policy.
\end{lstlisting}
\end{frame}
% slide 20
\begin{frame}[fragile]{YACPL Syntax (2)}
\lstset{language=Coq}
\begin{lstlisting}
Inductive primInclusivePolicySet : Set :=
  | PrimitiveInclusivePolicySet : preRequisite -> policy -> primInclusivePolicySet.

Inductive primExclusivePolicySet : Set :=
  | PrimitiveExclusivePolicySet : preRequisite -> policy  -> primExclusivePolicySet.

Inductive primPolicySet : Set :=
  | PIPS : primInclusivePolicySet -> primPolicySet
  | PEPS : primExclusivePolicySet -> primPolicySet.

Inductive policySet : Set :=
  | PPS : primPolicySet -> policySet.

\end{lstlisting}
\end{frame}
% slide 21
\begin{frame}[fragile]{Decision Procedures and the sumbool type}
\lstset{language=Coq}
\begin{lstlisting}
Inductive sumbool (A B:Prop) : Set :=
  | left : A -> {A} + {B}
  | right : B -> {A} + {B}
 where "{ A } + { B }" := (sumbool A B) : type_scope.
\end{lstlisting}
\begin{itemize}
\item sumbool is a boolean type equipped with the justification of their value, which really helps with proofs
\item Like bool and other 2-constructor inductive types, one can use the ``if then else'' construct to select the case. 
\item See ahead the trans\_policy\_PIPS slide and others for an example of how ``if then else'' is used
\item trans\_prin\_dec has been defined as below and proven in the source code
\end{itemize}
\lstset{language=Coq}
\begin{lstlisting}
Theorem trans_prin_dec : 
    forall (x:subject)(p: prin), {trans_prin x p} + {~trans_prin x p}.
\end{lstlisting}
\end{frame}
% slide 22
\begin{frame}[fragile]{answer and result types}
\Large
\lstset{language=Coq}
\begin{lstlisting}

Inductive answer : Set :=
  | Permitted : answer
  | Unregulated : answer
  | NotPermitted : answer.



Inductive result : Set :=
  | Result : answer -> subject -> act -> asset -> result.
\end{lstlisting}
\end{frame}

% slide 23
\begin{frame}[fragile]{YACPL Semantics: trans\_ps (1)}
\lstset{language=Coq}
\begin{lstlisting}
if (eq_nat_dec asset_from_query a)
then (* asset_from_query = a *)  
    match ps with
      | PPS pps => process_single_ps pps
    end
else (* asset_from_query <> a *)
       (Single 
          (makeResult 
             Unregulated subject_from_query action_from_query asset_from_query)).

\end{lstlisting}
\end{frame}
% slide 24
\begin{frame}[fragile]{YACPL Semantics: trans\_ps (2)}
\lstset{language=Coq}
\begin{lstlisting}

 match pps with 
    | PIPS pips => 
        match pips with 
          | PrimitiveInclusivePolicySet prq p => 
            (trans_policy_PIPS e prq p subject_from_query prin_u a action_from_query)                
        end
    | PEPS peps => 
        match peps with 
          | PrimitiveExclusivePolicySet prq p => 
            (trans_policy_PEPS e prq p subject_from_query prin_u a action_from_query)
        end  
   end
\end{lstlisting}
\end{frame}
% slide 25
\begin{frame}[fragile]{YACPL Semantics: trans\_policy\_PIPS}
\lstset{language=Coq}
\begin{lstlisting}
if (trans_prin_dec x prin_u)
    then (* prin *)
      if (trans_preRequisite_dec e x prq (getId p) prin_u)
      then (* prin /\ prq *)
        (trans_policy_positive e x p prin_u a action_from_query)                           
      else (* prin /\ ~prq *)
        (trans_policy_unregulated e x p a action_from_query)
    else (* ~prin *)
      (trans_policy_unregulated e x p a action_from_query).

\end{lstlisting}
\end{frame}

% slide 26
\begin{frame}[fragile]{YACPL Semantics: trans\_policy\_PEPS}
\lstset{language=Coq}
\begin{lstlisting}
  if (trans_prin_dec x prin_u)
  then (* prin *)
    if (trans_preRequisite_dec e x prq (getId p) prin_u)
    then (* prin /\ prq *)
      (trans_policy_positive e x p prin_u a action_from_query)
    else (* prin /\ ~prq *)
      (trans_policy_unregulated e x p a action_from_query)
  else (* ~prin *)
    (trans_policy_negative e x p a action_from_query).

\end{lstlisting}
\end{frame}

% slide 27
\begin{frame}[fragile]{YACPL Semantics: trans\_policy\_positive}
\lstset{language=Coq}
\begin{lstlisting}
match pp with
    | PrimitivePolicy prq' policyId action =>
        if (trans_preRequisite_dec e x prq' (Single policyId) prin_u)
        then (* prin /\ prq /\ prq' *)
          if (eq_nat_dec action_from_query action)
          then
            (Single 
              (makeResult Permitted x action_from_query a))
          else
            (Single 
              (makeResult Unregulated x action_from_query a))
               else (* prin /\ prq /\ ~prq' *)
          (Single 
              (makeResult Unregulated x action_from_query a))
      end.
\end{lstlisting}
\end{frame}
% slide 28
\begin{frame}[fragile]{YACPL Semantics: trans\_policy\_negative}
\lstset{language=Coq}
\begin{lstlisting}
match pp with
    | PrimitivePolicy prq' policyId action =>
 
          if (eq_nat_dec action_from_query action)
          then
            (Single 
              (makeResult NotPermitted x action_from_query a))
          else
            (Single 
              (makeResult Unregulated x action_from_query a))

  end.

\end{lstlisting}
\end{frame}
% slide 29
\begin{frame}[fragile]{YACPL Semantics: trans\_policy\_unregulated}
\lstset{language=Coq}
\begin{lstlisting}
match pp with
    | PrimitivePolicy prq' policyId action =>
        (Single (makeResult Unregulated x action_from_query a))
  end.
\end{lstlisting}
\end{frame}
%% slide 35
\begin{frame}[fragile]{Conclusion}
\Large
\begin{itemize}
\item A Core Policy Language Potentially Suitable for both DRM and general purpose Access-Control systems with 
\item Formal Semantics 
\item Where Answering a Query is Certifiably Decidable
\item Executable Programs can be Extracted from the Proof and used to Answer Queries for specific Policies.
\item You can access the source code at https://github.com/bsistany/yacpl.git
\end{itemize}
\end{frame}
%% slide 16
\begin{frame}[fragile]{Defining Rights}
\end{frame}
%% slide 17
\begin{frame}[fragile]{Defining Rights}
\end{frame}
%% slide 18
\begin{frame}[fragile]{Defining Rights}
\end{frame}
%% slide 19
\begin{frame}[fragile]{Defining Rights}
\end{frame}
%% slide 20
\begin{frame}[fragile]{Defining Rights}
\end{frame}
%% slide 21
\begin{frame}[fragile]{Conclusion}
\end{frame}
%% slide 22
\begin{frame}[fragile]{Questions?}
\end{frame}






























\end{document}
